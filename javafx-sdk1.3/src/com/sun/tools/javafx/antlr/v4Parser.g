/*
 * Copyright 2007-2009 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4 of the JavaFX parser grammar.
//
// @author Jim Idle - Temporal Wave LLC
//
// Version 4 of the grammar reverts to a separate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// JavafxTree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar v4Parser;

options { 

	// Rather than embed parser oriented Java code in this grammar, just to override
	// methods in the ANTLR base recognizer and derviative classes, we
	// instruct ANTLR to generate a class which is dervied from our own
	// super class. The super class is where we embody any code that does
	// not require direct access to the methods generated 
	// to implement the parser. Hence for instance this is where the 
	// JavafxTreeMaker lives.
	//
	superClass 	= AbstractGeneratedParserV4; 

	// Import the token vocabulary, generated by the
	// lexer grammar analysis.
	//
	tokenVocab	= v4Lexer;
}

tokens
{
	LAST_TOKEN;
}

// This scope is used by rules that wish to change the
// location in which the error processing routines store the
// Erroneous nodes they create.
//
// As the parser descends the ruleset it needs to know where in the AST it
// should accumulate Erroneous nodes that represent parsing errors. Parsing
// errors do not always cause the rule that they occur in to receive an
// exception and therfore create an Erroneous node instead of whatever
// they would normally create. But we need to create an Erroneous node so
// that the error sink recives both start and end positions and so that the
// IDE can locate the error in the AST. The issue is where in the AST the
// error should be accumulated. If we are in the middle of a class definition
// then the error should be there, in a function definition, then part of the function
// definition and so on. 
//
// Each rule that need to change the error accumulation location creates
// a scope entry in this global scope and sets the ASTErrors member to be
// a reference to the list of things it is producing. The error routines then
// just append Erroneous nodes to the ListBuffer that is within the top
// entry of the stack.
//
scope errorStack {

	// Where the error routines should append any Erroneous nodes that
	// they create. We cannot use generics here as we are not always
	// accumulating JFXTree.
	//
	ListBuffer	 ASTErrors;
	
}
// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package com.sun.tools.javafx.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.mjavac.tree.*;
import com.sun.tools.javafx.tree.*;
import com.sun.javafx.api.tree.*;

import com.sun.tools.mjavac.util.*;
import com.sun.tools.javafx.util.MsgSym;

import com.sun.tools.mjavac.code.*;
import com.sun.tools.javafx.code.JavafxFlags;
import static com.sun.tools.mjavac.util.ListBuffer.lb;
import com.sun.javafx.api.JavafxBindStatus;

import static com.sun.javafx.api.JavafxBindStatus.*;

}
 
@parser::members {

    /** Report a recognition problem.
	 *
	 *  This method sets errorRecovery to indicate the parser is recovering
	 *  not parsing.  Once in recovery mode, no errors are generated.
	 *  To get out of recovery mode, the parser must successfully match
	 *  a token (after a resync).  So it will go:
	 *
	 * 		1. error occurs
	 * 		2. enter recovery mode, report error
	 * 		3. consume until token found in resynch set
	 * 		4. try to resume parsing
	 * 		5. next match() will reset errorRecovery mode
	 *
	 * Note that because we must access the global scope stack, we cannot
     * place this method in the super class.
	 */
    @Override
	public void reportError(RecognitionException e) {

		// If we've already reported an error and have not matched a token
		// yet successfully, don't report any errors.
        //
		if ( state.errorRecovery ) {

            // Don't count spurious
            //
			return;
		}
		state.syntaxErrors++;
		state.errorRecovery = true;

		displayRecognitionError(this.getTokenNames(), e);
        
        // The displayRecognitionError() method creates an Erroneous
        // node that spans the error. As we were nto given a specific
        // AST node by which to report the error to the diagnostic listener
        // then we append this error node to the list of elements the
        // parser is accumulating, whcih is always the ListBuffer at the
        // top of the global scope 'errorStack'
        //
        errorStack_scope es = ((errorStack_scope)errorStack_stack.peek());
        es.ASTErrors.append(errorNode);
        
	}

   /**
     * Acts as per the standard error reporting, but instead of allowing the
     * normal displayRecognition error to report with reference to the tokens
     * it has consumed, we always report with reference to the supplied node.
     *
     * Because the standard reportError() method must reside in the generated
     * class so it has access to the scope class, we keep this version of the 
     * method here too, for consistency.
     
     * @param e The recognition exception to report on
     * @param node The node we wnat to report with reference to.
     */
    public void reportError(RecognitionException e, JFXTree node) {

        // if we've already reported an error and have not matched a token
		// yet successfully, don't report any errors.
        //
		if ( state.errorRecovery ) {

            // Don't count spurious
            //
			return;
		}

		state.syntaxErrors++;
		state.errorRecovery = true;

		displayRecognitionError(this.getTokenNames(), e, node);

    }	
}
// ------------------------------------------------------------------    	
// ------------------------------------------------------------------
// PARSER RULES
//
// The parser consumes the token stream created by calling the lexer until
// we see EOF. When the parser starts, the entire token stream is created.
// We cannot do syntax directed parsing as it means you cannot use LL(*)
// algorithms for grammar analysis and code generation.
//
// The parsers job is to produce the JavaFX specialized AST, which
// is the basis for all the rest of the tool chain, including symbol table and code 
// generation as well as code completion for editors and so on.
// ------------------------------------------------------------------

/**
 * The usual entry point for the JavaFX parser, this will parse a complete
 * script body and manufacture the JavaFX AST.
 *
 * A script, like many other syntactical elements, can have an associated
 * comment. When the parse is complete, we scan the tokens that are normally
 * hidden from the parser looking for comments and associate them with
 * AST node for the script.
 */
script

	returns	[JFXScript result]
	
// Where the error routines should accumulate erroneous nodes. There
// should not really be any accumulated here, but perhaps the packageDecl
// routine may throw something out.
//	
scope errorStack;

@init
{
	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// AST start position
	//
	int	rPos = pos();
	
	// Initialize the tree map if we are creating the AST end position
	// map.
	//
	endPositions = genEndPos ? new HashMap<JCTree,Integer>() : null;
	
	// Initialize document comment collection
	//
	docComments	= null;
	
	// Initialize the error accumulator
	//
	$errorStack::ASTErrors = new ListBuffer<JFXTree>();
}

	:  pd=packageDecl si=scriptItems 
	
		{
			// If the parser threw out any error messages, we want to
			// enter them in to the AST for later analysis if required, but mainly
			// so they are available to the log sync. The only errors accumulated here
			// have to be before the script items, so they are prepended to the
			// item list, rather than appended
			//
			for	(Object e : $errorStack::ASTErrors) {
				$si.items.prepend((JFXTree)e);
			}
			
			// Construct the JavFX AST
			//
			$result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment);	// Add any detected documentation comment
            
   			// Set tree span and endpoint map (if required).
        	//
        	$result.pos = rPos;
        	endPos($result); 
        	
        	// Pass on the documentation comments and the endpos map
        	//
        	$result.docComments 	= docComments;
        	$result.endPositions	= endPositions;

		}

		EOF 	// Forces parser to consume entire token stream or error out
    ;
    
// ----------------------    
// Package specification.
// The package declaration is optional. It qualifes the namespace/location
// of all subsequent delcarations in the script.
//
packageDecl

	returns [JFXExpression value] 	// Package declaration builds a JFXExpression tree

@init
{
	// AST start position
	//
	int	rPos = pos();
}
    : PACKAGE qualname possiblyOptSemi
    
    		{ 
    			$value = $qualname.value;
    		}
    		
    | // No package specified
    
    		{ $value = null; }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Error node for AST
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

	
	returns [ListBuffer<JFXTree> items = new ListBuffer<JFXTree>()] // This rule builds a list of JFXTree, which is used 
																	// by the caller to build the actual AST.
																	//
																	
// Where the error routines should accumulate erroneous nodes. Any errors 
// here are at the script level of course.
//	
scope errorStack;

@init
{
	// AST start position
	//
	int	rPos = pos();
	
	// Where to append any Erroneous nodes
	//
	$errorStack::ASTErrors = $items;
	
}
	:	(scriptItem[$items] possiblyOptSemi)*
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Error node for AST
	//
	JFXErroneous value = F.at(rPos).Erroneous();
	endPos(value);
	$items.append(value);
	
 }
 
scriptItem  [ListBuffer<JFXTree> items] // This rule builds a list of JFXTree, which is used 
										// by the caller to build the actual AST.
										//
@init
{
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
}
	:
			  // Certain script members may be prefixed with modifiers
			  // such as 'public'. We allow the parser to first consume 
			  // all modifier keywords, regardless of whether this is a 
			  // valid modifier for the upcoming declaration. Whether it is
			  // valid or not is a matter for semantic checks to decide.
			  //
			  //
			  	(modifiers (CLASS|FUNCTION))=> m1=modifiers { errNodes.append($m1.mods); }
				(
					  c=classDefinition			[$m1.mods, $m1.pos]
					  
					 		{ 	errNodes.append($c.value);
								$items.append($c.value); 
							}
							
					| f=functionDefinition    	[$m1.mods, $m1.pos]
					

					 		{ 
					 			errNodes.append($f.value);
								$items.append($f.value); 
							}
				)
				
			| i=importDecl
			
				{ 
					errNodes.append($i.value);
					$items.append($i.value); 
				}
			
			| s=statement
			
				{ 
					errNodes.append($s.value);
					$items.append($s.value); 
				}
			
			| SEMI
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input. If we receive an exception here
// it is because whatever token was next in the input stream did not predict
// any of the alts. So, we recover the input stream up to the next token
// in the followset (standard ANTLR recovery), then build an erroneous node
// that contains no sub trees, but identifies the start and end of the
// error
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Now construct an Erroneous node to span the error nodes
	// 
	JFXErroneous errors = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errors);
	
	// And add this in to the script item list
	//
	$items.append(errors);
 }
 
// -----------------	
// Import statement.
// Include definitions from an external source
//
importDecl

	returns [JFXTree value] // The import declaration is built as a generic JFXTree

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	

}
	
 	: IMPORT importId
 	
 		{
 			// AST construction
 			$value = F.at(rPos).Import($importId.pid);
 			
 			// AST span
 			//
			endPos($value);
 		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Error node for AST, note that if we found an importId then we would
	// not be in the exception handler, so no need to accumulate it for
	// error.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);

 }
 
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

	returns [JFXExpression pid]	// Qualified names are built as expression trees

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	
	// Flag indicates that the token sequence was in error
	//
	boolean	inError = false;
	
	// Flag indicates that we have seen .'*' already
	//
	boolean haveStar = false;
	
	// Record the posiotn of any START we find, in case we want to error upon it
	//
	int	starP = 0;
}
 	: i1=identifierAll
 		{
 			$pid = $i1.value;
 			
 			// Accumulate in case of error, and flag if the indentifer was not there
 			//
 			errNodes.append($i1.value);
 			inError = $i1.inError;
 		}
		( 
			(
				  DOT 
				| DOTDOT
					{
						// If the programmer accidentally typed import X..y; then the
						// lexer will see that as a range operator, but here, that tells
						// us there was a missing qualifer
						//
						inError = true;		// Signal that this is malformed
						log.error(pos($DOTDOT)+1, MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
					}
			)
				(
					(nameAll)=> n2=nameAll
					{
						// Check for errors
						//
						if	($n2.inError || $n2.value == null)
						{
							// We should not be able to get this, as the follow set
							// will not allow error recovery to insert a token as
							// it is not singular - which one should it insert? However
							// future improvements may make this happen, so code for it anyway
							//
							log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
						}
						
						$pid = F.at($n2.pos).Select($pid, $n2.value);
                	    endPos($pid);
                    
                	    // Build up new node in case of error
						//
						JFXExpression part = F.at($n2.pos).Ident($n2.value);
						errNodes.append(part);
						endPos(part);

						// If we already had a '.*' part, then this makes no sense
						//
						if	(haveStar) {
						
							inError = true;		// Signal that this is malformed
							log.error(part, MsgSym.MESSAGE_JAVAFX_IMPORT_BAD_NAME);
						}
					}

				| 	(STAR)=>s1=STAR (s2=STAR)?
        	
        			{
        				// Whether '*' || '**'
        				//
        				Name starBit;
        				
        				if	($s2 == null) {
        				
        					// Second star was not present
        					//
        				  	starBit = names.asterisk;
        				  	
  
        				  	
        				} else {
        				
        					// Second star WAS present
        					//
        					starBit = names.fromString("**");
        					
        					// Note that ** has been reverted from the runtime, so we just
        					// replace it with single star for the moment, and issue an error
        					// Delete this comment and the next two lines when the runtime supports 
        					// this again.
        					//
        				  	inError = true;		// Signal that this is malformed
        				  	starBit = names.asterisk;
        				  	JFXExpression part = F.at(starP).Ident(starBit);
							endPos(part);
        				  	log.error(part, MsgSym.MESSAGE_JAVAFX_IMPORT_BAD_STAR);
        				  	
        				}
        				
						$pid = F.at($n2.pos).Select($pid, starBit);
                	  	endPos($pid);

                	  	// Build up new node in case of error
						//
						starP = pos($s1);
						JFXExpression part = F.at(starP).Ident(starBit);
						errNodes.append(part);
						endPos(part);
						
						// If we already had a '.*{*}' part, then this makes no sense
						//
						if	(haveStar) {
						
							inError = true;		// Signal that this is malformed
							log.error(part, MsgSym.MESSAGE_JAVAFX_IMPORT_BAD_STAR);
						}
						
						
						// Signal that we have a star now
						//
						haveStar = true;
					}
					
				|	// Erroneous
				
					{
						// THis does not cause an errneous node, we just generate a missing
						// qualifier.
						//
						Name missing = Name.fromString(names, "<missing>");
						JFXExpression part = F.at(semiPos()).Ident(missing);
						errNodes.append(part);
						endPos(part);
						$pid = F.at(pos($DOT)).Select($pid, missing);
						endPos($pid);
						log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
					}
					
				)

        )*
        
        {
        	// Was the seqeunce in error? Note that not all syntax errors
        	// cause this. 
        	//
        	if	(inError) {
        		$pid=F.at(rPos).Erroneous(errNodes.elems);
        		endPos($pid);
        	}
        }
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// And we need to return an erroneous node
	//
	$pid=F.at(rPos).Erroneous(errNodes.elems);
    endPos($pid);  	
 }
 

// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the smeantics of the modifiers.
//
modifiers

	returns [JFXModifiers mods, int pos]	// Constructs and returns a specialized modifer node

@init {

	// The flags we build up for the AST
	//
	long	flags 	= 0;
	
	// The start character position for this AST
	//
	$pos		= pos();
}

	: 	(	
			mf=modifierFlag
			
			{
				// Or in the newly discovered modifier
				//
				flags	|= $mf.flag;
			}
	
		)*
		
		{
			// Build the modifier flags (just as empty if we did not pick any up)
			//
			$mods = F.at($pos).Modifiers(flags);

			// Tree span
			//
			endPos($mods);
		}
	;

 
// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

	returns [long flag]
	
	: ABSTRACT			{ $flag = Flags.ABSTRACT;				}
	| BOUND				{ $flag = JavafxFlags.BOUND;			}
	| MIXIN				{ $flag = JavafxFlags.MIXIN;			}
	| OVERRIDE			{ $flag = JavafxFlags.OVERRIDE;			}
	| PACKAGE			{ $flag = JavafxFlags.PACKAGE_ACCESS;	}
	| PROTECTED			{ $flag = Flags.PROTECTED;				}
	| PUBLIC			{ $flag = Flags.PUBLIC;					}
	| PUBLIC_READ   	{ $flag = JavafxFlags.PUBLIC_READ;		}
	| PUBLIC_INIT		{ $flag = JavafxFlags.PUBLIC_INIT;		}
        
	
	//TODO: deprecated -- remove these at some point
	//                    For now, error about their deprecation
	//
	| PRIVATE			{ 
							JFXErroneous err = F.at(pos($PRIVATE)).Erroneous();
							endPos(err);
							log.error(err, MsgSym.MESSAGE_JAVAFX_NOT_SUPPORTED_PRIVATE); 
						}
	| STATIC			{ $flag = Flags.STATIC;      			}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
 }
 
// Class definition.
// Parses a complete class definition and builds up the JFX AST
// that represents this.
//
// param mods The previously built modifier flags
//
classDefinition [ JFXModifiers mods, int pos ]

	returns [JFXTree value]	// The class definition has its own JFXTree type, but we might need Erroneous here
	
	// Shift contexts for error accumualtion
	//
	scope errorStack;
	
@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment 		= getDocComment(input.LT(1));

	// List of all members
	//
	ListBuffer<JFXTree> mems		= new ListBuffer<JFXTree>();
	
	// Super class ids
	//
	ListBuffer<JFXExpression> ids	= null;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	$errorStack::ASTErrors 			= mems;

}

	: CLASS 
	
			n1=name 
			
			supers	{ids = $supers.ids; }
			
		LBRACE 
	
			// Consume any garbled declarations so that we don't drop out
			// of parsing the class until we hit '}' for the class definition
			// or get to something that is so garbled we have no choice.
			//
			syncClass		[mems] 
			
			( 
				classMember 		[mems] 
				
				possiblyOptSemi
				
				syncClass 			[mems]
			)*
			
		RBRACE
		
		{ 
			$value = F.at($pos).ClassDeclaration
				(
	  						  
					$mods,	
					$n1.value,
					ids.toList(),
					mems.toList()
				);
				setDocComment($value, docComment);	// Add any detected documentation comment
				endPos($value, pos($RBRACE)); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// However, we need to collect the nodes we found into an Erroneous class
	// definition, as if the got an error in this rule, it was a pretty high
	// up problem, syntactically. Something like "public class" and nothing else
	// which can of course come in from IDEs/Editors, all the time. Because the
	// parser is pretty good at recovering from nonsense in the declaration, we will
	// usually only get here for missing elements of the class definition. So, rather
	// than always throwing the entire class into an erroneous state, we see if we 
	// have enough to build a class definition that the IDE can use anyway. The 
	// litmus test for that is whether we gathered any member definitions at all.
	// If we did, then we will have a class name and 0 or more supers and so on
	// and so we can build the class definition. (Quite often we get here because of a lack
	// of a closing '}', so we don;t want to abandon the class just because of that.
	//

	// We always have enough to build a class definition AST for the IDE because we will
	// manufacture a name of <missing> if there wasn't one. That's all the class node
	// really needs.
	// 
	$value = F.at($pos).ClassDeclaration
				(			  
					$mods,	
					$n1.value,
					ids.toList(),
					mems.toList()
				);
		setDocComment($value, docComment);	// Add any detected documentation comment
	
	// AST span
	//
	endPos($value);
	
 }
 
// -----------------
// Super class spec.
// Parses a list of super classes for a class definition and builds the
// associated JFX AST.
//
supers 

	returns [ListBuffer<JFXExpression> ids = new ListBuffer<JFXExpression>()]	// The return is a list of JFX expressions representing one
																				// or more super class type name.
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start position in case of error
	//
	int	rPos = pos();
}
	: EXTENDS t1=typeName
			{
				$ids.append($t1.value);			// First type name in list
				errNodes.append($t1.value);		// Accumulate in case of error
			}
           ( 
           	COMMA t2=typeName 
           	
           		{ 
           			$ids.append($t2.value); 
           			errNodes.append($t2.value);
           		}
           )*
           
	| // Upsilon - this class inherits no other types so the list will be empty
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Produce the ERRONEOUS node
	//
	$ids = new ListBuffer<JFXExpression>();
	JFXErroneous errnode = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errnode);
	$ids.append(errnode);
 }
 	
 // ---------------------------- 
// Statement/Expression resync for class declaration.
// If left to itself, the class rule cannot easilly resync to the start of a statement
// because we will throw an exception on trying to work out if we can insert or
// delete a token.
//
// If we use this rule after the open '{' before the start of every complete/recoverable
// definition contained in a declarations block, then it will be called unconditionally (it always
// matches the next token because it is the upsilon set). Most importantly, the followset
// stack will contain the follow set that is allowed to start a new declaration. Hence our
// init rule just uses the trick of syncing to the next good declaration, and throwing out
// any garbled definitions with a neat error. We will always be positioned at a token that
// can start a new defintion, or the closing '}' or in rare cases, then the sync funciton 
// will have to give in because the code is just too garbled (but all bets are off at that
// point.)
// 
// We record the token stream start position on rule entry, and upon rule exit
// if we consumed any tokens, then we add an Erroneous node to the AST and everyone is
// happy.
//
syncClass[ListBuffer<JFXTree> mems]
@init
{
	// Start of rule for error node production
	//
	int	rPos	= pos();
	
	// Consume any garbled tokens that come before the next statement
	// or the end of the block. The only slight risk here is that the
	// block becomes MORE inclusive than it should but as the script is
	// in error, this is a better course than throwing out the block
	// when the error occurs and screwing up the whole meaning of
	// the rest of the token stream.
	//
	syncToGoodClassToken();  // Temporary method call - found bug in ANTLR 3.1 followset computation!
}
@after
{
	// If we consume any tokens at this point then we create
	// an ERRONEOUS AST node for the IDE to monitor and add it
	// in to the staement list.
	//
	if	(rPos != pos()) {
	
		// Span all the tokesn we had to consume.
		//
		JFXErroneous errNode = F.at(rPos).Erroneous();
		endPos(errNode);
		$mems.append(errNode);
		
		// Tell the script author where we think there is a screwed up expression
		//
		log.error(errNode, MsgSym.MESSAGE_JAVAFX_GARBLED_DECLARATION);
	}
}
	:	// Deliberately match nothing, causing this rule always to be 
		// entered.
	;


 
// --------------
// Class members.
// Parses all constructs that can be a member of a class and returns
// the JAva FX AST that represents it.
//
classMember[ListBuffer<JFXTree> mems]

 	returns [JFXTree member]		// A class member has a specialized JFX tree node, which is what
									// we return from this rule.

 @init {

	// The start character position for this AST
	//
	int rPos		= pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	: initDefinition				{ $mems.append($initDefinition.value); 		}
	| postInitDefinition			{ $mems.append($postInitDefinition.value); 	}
	|
		m=modifiers 
	  
		(
		   variableDeclaration		[$m.mods, $m.pos] 		{ $mems.append($variableDeclaration.value); }
		 | functionDefinition		[$m.mods, $m.pos]		{ $mems.append($functionDefinition.value); 	}
	)
	| SEMI
	
	;
	
// Catch an error when looking for a class member. We create an erroneous node
// for anything that was at the start up to wher
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform custom resyncing for class members
	//
	$mems.append(resyncClassMember(rPos, re));
	
 }

// ----------
// Functions.
// While funcitnos can be declared at any level, their syntax is the same.
// As always, the semantic pass of the JFX tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition [ JFXModifiers mods, int pos ]

	returns [JFXTree value]		// A function defintion has a specialized node in the JavaFX AST

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Function name we accumulate one way or another (manufacture if missing)
	//
	JFXIdent id;
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
	// Is this an override?
	//
	boolean isOverride = (JavafxFlags.OVERRIDE & $mods.flags) == JavafxFlags.OVERRIDE;
	
	// The Name symbol we create
	//
	Name name = null;
}
	: FUNCTION 
		
		(
			(
				  { isOverride }?=> n2=nameAll
					{
						if ($n2.inError || $n2.value == null) {
						
							// First, lets report the error as the user needs to know about it
							// Issue an error - can't have anonymous functions
							//
							log.error(pos(), MsgSym.MESSAGE_JAVAFX_FUNC_UNNAMED);
						}
						// Accumulate a node in case of error
						//			
						id = F.at($n2.pos).Ident($n2.value);
						name = $n2.value;
						endPos(id);
					
						// Accumulate in case of error
						//
						errNodes.append(id);
					}
				  
				| n1=name
					{		
						if ($n1.inError || $n1.value == null) {
						
							// First, lets report the error as the user needs to know about it
							// Issue an error - can't have anonymous functions
							//
							log.error(pos(), MsgSym.MESSAGE_JAVAFX_FUNC_UNNAMED);
						}
						// Accumulate a node in case of error
						//			
						id = F.at($n1.pos).Ident($n1.value);
						name = $n1.value;
						endPos(id);
					
						// Accumulate in case of error
						//
						errNodes.append(id);
					}
				
			)
				
		)
		formalParameters
			{
				// Accumulate the parameter nodes in case of error
				//
				for	(JFXTree t : $formalParameters.params) {
					errNodes.append(t);
				}
			}
			
		typeReference 
			{
				// Accumulate in case of error
				//
				errNodes.append($typeReference.rtype);
			}
	
		// The function block is optional if this is an abstract funtino definition
		// but in that case a semi colon is required. If this is not an abstract function
		// we let the attribution function report that there is no function body defined
		// as this may be coming from an IDE.
		//
		(	  (LBRACE)=>block [-1]
		
				{
					// Accumulate in case of error
					//
					errNodes.append($block.value);
				}
			
			| 	// This alt is selected only if the function declaration is not abstract
				// and there was no function body. If there is a SEMI at this point, it does not
				// matter as it will be eaten by the enclosing rule as if it were an empty statement.
				//
		)
	
		{
			// Create the function defintion AST
			//
			$value = F.at($pos).FunctionDefinition
							(
								$mods,
								name, 
								$typeReference.rtype,
								$formalParameters.params.toList(), 
								$block.value
							);
							
			// Ensure that the function value, manufactured within the FunctionDefinition() method
			// call, receives an endPos() map
			//
			endPos(((JFXFunctionDefinition)($value)).operation);
			
			// Documentation comment (if any)
			//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Produce an error node rather than a function definition node.
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
 }
 
 
// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initDefinition

	returns [JFXTree value]	// The initialisation block has a specialized JFX tree node

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: INIT block [ -1 ]
	
		{
			// Build the AST
			//
			$value = F.at(pos($INIT)).InitDefinition($block.value);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// If we took an exception, then there will not be a block to construct
	//
	$value = F.at(rPos).Erroneous();
 }
 
// Post initialization.
// Parse the post initialization block and produce the AST
//
postInitDefinition

	returns [JFXTree value]	// Post initialization has its own specialized JFX tree node

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: POSTINIT block [-1]
		{ 
			// Build the AST
			//
			$value = F.at(pos($POSTINIT)).PostInitDefinition($block.value);

			// Tree span
			//
			endPos($value); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// If we took an exception, then there will not be a block to construct
	//
	$value = F.at(rPos).Erroneous();
 }
 
//triggerDefinition
//	: WITH name onReplaceClause		-> ^(WITH name onReplaceClause)
//	;


// Variables.
// While they can be defined at different levels (script, member, local) the syntax
// for declaring variables, and the modifiers and so on are all exactly
// the same (syntactically) at all levels.
// Parser a variable declaration and return the resultant JFX expression tree.
//
variableDeclaration [ JFXModifiers mods, int pos ]

	returns [JFXExpression value]

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

    // Bind status if present
    //
    JavafxBindStatus bStatus = null;

    // Bind value expression, if present
    //
    JFXExpression bValue = null;

    // does thie variable have an on-replace trigger?
    //
    boolean seenOnReplace = false;

    // does thie variable have an on-invalidate trigger?
    //
    boolean seenOnInvalidate = false;

    // ONReplace clause if present
    //
    JFXOnReplace  onReplaceValue = null;

    // ONInvalidate clause if present
    //
    JFXOnReplace  onInvalidateValue = null;
 
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
   
   	// Used by error accumulation and override construction
   	//
   	JFXIdent part = null;
   
}
	: variableLabel  
	
		n=name
		
			{ 
				// Build up new node in case of error
				//
				part = F.at($n.pos).Ident($n.value);
				endPos(part, $n.pos);	// Was not really there
				errNodes.append(part);
			}
			
		tr=typeReference 	{ errNodes.append($tr.rtype); }  // Accumulate for errors

        (
              (EQ)=>EQ boundExpression
                {
                    bValue  = $boundExpression.value;
                    bStatus = $boundExpression.status;
                    errNodes.append($boundExpression.value);
                }
                
			| // Missing initializer. This is fine for var, but cannot be
			  // the case for def, so we create an erroneous node for the intializer
			  // in that case, and positoin it where the initializer should be.
			  //
			  {
			  	if	(($variableLabel.modifiers & JavafxFlags.IS_DEF) == JavafxFlags.IS_DEF) {
			  	
			  		// Create an erroneous node where we should have the intializer
			  		//
			  		bStatus = UNBOUND;
			  		bValue  = F.at(semiPos()).Erroneous();
			  		endPos(bValue);							// End pos will adjust span so that it is one character long.
			  		
			  		// Send out the error
			  		//
			  		log.error(bValue, MsgSym.MESSAGE_JAVAFX_BAD_DEF, $name.text);
			  	}
			  
			  }
        )
        
        (: (ON REPLACE)=>onReplaceClause
                {
                    onReplaceValue = $onReplaceClause.value;
                    if (seenOnReplace) {
                       log.error(onReplaceValue.pos(), MsgSym.MESSAGE_JAVAFX_DUPLICATE_TRIGGER_DEF);
                    }
                    else {
                        seenOnReplace = true;
                    }
                    errNodes.append($onReplaceClause.value);
                }
        
        |
        (ON INVALIDATE)=>onInvalidateClause
                {
                    onInvalidateValue = $onInvalidateClause.value;
                    if (seenOnInvalidate) {
                       log.error(onInvalidateValue.pos(), MsgSym.MESSAGE_JAVAFX_DUPLICATE_TRIGGER_DEF);
                    }
                    else {
                        seenOnInvalidate = true;
                    }
                    errNodes.append($onInvalidateClause.value);
                }
        )*
	
		{
			// Add in the modifier flags accumulated by the label type
			// Note that syntactically, we allow all label types at all levels and must throw
			// out any invalid ones at the semantic checking phase
			//
			$mods.flags |= $variableLabel.modifiers;
	    	
	    	// Construct the variable JFXTree, unless it was in error
	    	//
	    	if	($n.inError) {
	    	
	    		$value = F.at($pos).Erroneous(errNodes.elems);
	    		
	    	} else {
	    	
	    		// Here, we can have either an OVERRIDE or a striaght
	    		// declaration, but the AST nodes are different.
	    		//
	    		if	(($mods.flags & JavafxFlags.OVERRIDE) == JavafxFlags.OVERRIDE) {
	    		
	    			// Build the AST for OVERRIDE var
					//
					$value = F.at($pos).OverrideClassVar
						(
                                                        $name.value,
                                                        $typeReference.rtype,
                                                        $mods,
                                                        part,
							bValue,
							bStatus,
							onReplaceValue,
                                                        onInvalidateValue
						);

	    		} else {
			    
			    	$value = F.at($pos).Var
			    				(
			    					$name.value,
			    					$typeReference.rtype,
			    					$mods,
			    					bValue,
			    					bStatus,
			    					onReplaceValue,
                                                                onInvalidateValue
			    				);
			    }
	    	}
	    	// Documentation comment (if any)
	    	//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}	
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Enter into AST as an erroneous node
	//
	$value = F.at($pos).Erroneous(errNodes.elems);
	endPos($value);
	
 }
 
// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters

	returns [ListBuffer<JFXVar> params = new ListBuffer<JFXVar>()]		// Return type is a list of all the AST nodes that represent a 
																		// formal parameter, this is used to generate the AST for the
																		// funciton definition itself.
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: LPAREN 
	
		(
			fp1=formalParameter 
	
			{
				// Capture the first parameter
				//
				params.append($fp1.var); 
			}
			(
				COMMA fp2=formalParameter
				
					{ 
						// Second and subsequent parameter ASTs
						//
						params.append($fp2.var); 
					} 
			)*
			COMMA?  
		)?
			
	  RPAREN
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Because we have raised the error, we won't perform codegen, but we can
	// leave the list in tact so that the IDE has something to work with. The list
	// is optional, so even if we have gathered none, we are still good.
	//
 }
 
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

	returns [JFXVar var]	// Formal parameters are contained in a JFX tree var node.
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: name typeReference
	
		{ 
			if ($name.inError) {
			
				// Looks like the name was missing, create an erroneous var instead
				// Build up new node in case of error
				//
				JFXExpression part = F.at($name.pos).Ident($name.value);
				errNodes.append(part);
				endPos(part);
				errNodes.append($typeReference.rtype);
				
			} else {
			
				$var = F.at($name.pos).Param($name.value, $typeReference.rtype);
			}
			endPos($var); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Because both name and typeReference will recover with something
	// sensible, we don't ned to create anything here. In theory, we can't
	// even get here.
	//
 }
 
// ------
// block.
// A block component is actually a unit that returns a value, it is an expression.
// In certain contexts the braces are more lexigraphically significant, such as the
// boundaires of if blocks. Hence those contexts specify the block directly rather than
// leaving the expression statement to pick it up.
//
// This means that a statement such as:
//
// if (x) { y} -z
//
// Does not consume the { y } -z as a complete expression but does
// what a programmer intuitively expects and uses only {y } as the
// subject of the if, with -z being a separate expression statement.
//
// A programmer can treat the above construct as a single expression
// by enclosing it in braces:
//
// if (x) { { y } -z }
//
// Which is then obvious. This also improves error recovery possibilities,
// which is a requirement for code completion utilities and so forth.
//
// Accepts an incoming character so that the block node can be created to
// include a prior token suchas 'finally' or 'try' etc.
//
block [ int inPos]

	returns [JFXBlock value]	// The block expression has a specialized node inthe JFX tree

// Where the error routines should append any errors
//
scope errorStack;

@init { 

	// A list of all the statement ASTs that make up the block expression
	//
	ListBuffer<JFXExpression> stats = new ListBuffer<JFXExpression>(); 
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	$errorStack::ASTErrors			= stats;

	// Start of rule for error node production/
	//
	int rPos = pos();
	if ($inPos != -1)
	{
		rPos = $inPos;
	}
	
	// Track the result expression of the block
	//
	JFXExpression resultType = null;
}
	: LBRACE 
	
		// Eat up any garbled tokens, ready for the first valid statement
		//
		st1=syncBlock[resultType, stats] { resultType = $st1.value; }
		(
			blkValue=blockElement[resultType, stats]
													
								{									
									// This new statement is now the result type of the block
									//
									resultType = $blkValue.value;
								}
								
			
			// Eat up any garbled tokens, ready for another statement
			//	
			st2=syncBlock[resultType, stats] { resultType = $st2.value; }
		)*
	
	  	{	
	  		// If the result of the last element was erroneous, then
			// make the result of the block be void, which means the
			// result of the block will never be Erroneous, as the tree walkers
			// can't handle that.
			//
			if	(resultType instanceof JFXErroneous) {
				stats.append(resultType);
				resultType = null;
			}
	  		// Ensure that the result node is tracked in the endpos table
	  		//
	  		endPos(resultType);
	  	}
	  	
	  RBRACE
	  	
	  	{
	  		
		  	$value = F.at(rPos).Block(0L, stats.toList(), resultType);
	  		endPos($value);
	  	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an erroneousBlock, which is basically an Erroneous node
	// masquerading as a JFXBlock, unless we managed to gather any
	// useful statements, in which case constrcut the block and add the
	// erroneous node created by reportError call above. This will usually be
	// the case and helps the IDE a lot.
	//
			
	// If the result of the last element was erroneous, then
	// make the result of the block be void, which means the
	// result of the block will never be Erroneous, as the tree walkers
	// can't handle that.
	//
	if	(resultType instanceof JFXErroneous) {
		stats.append(resultType);
		resultType = null;
	}
		
	// Create the block
	//
	$value = F.at(rPos).Block(0L, stats.toList(), resultType);
	endPos($value);
 }

// ---------------------------- 
// Statement/Expression resync.
// If left to itself, the block rule cannot easilly resync to the start of a statement
// because we will throw an exception on trying to work out if we can insert or
// delete a token.
//
// If we use this rule after the open '{' and at the end of every complete/recoverable
// statement contained in a block, then it will be called unconditionally (it always
// matches the next token because it is the upsilon set). Most importantly, the followset
// stack will contain the follow set that is allowed to start a new statement. Hence our
// init rule just uses the trick of syncing to the next good statement, and throwing out
// any garbled expressions with a neat error. 
// 
// We record the token stream start position on rule entry, and upon rule exit
// if we consumed any tokens, then we add an Erroneous node to the AST and everyone is
// happy.
//
syncBlock[JFXExpression returnType, ListBuffer<JFXExpression> stats]

	returns [JFXExpression value]
@init
{
	// Start of rule for error node production
	//
	int	rPos	= pos();
	
	// Consume any garbled tokens that come before the next statement
	// or the end of the block. The only slight risk here is that the
	// block becomes MORE inclusive than it should but as the script is
	// in error, this is a better course than throwing out the block
	// when the error occurs and screwing up the whole meaning of
	// the rest of the token stream.
	//
	syncToGoodToken();
	
	// If we are going to accumulate an erroneous node in the block, then
	// we first need to accumulate the current block return value and then return
	// the error node as the new return value. We do not add the errneous block
	// to the stats here, the caller wil do it within its accumulation loop.
	//
	$value = $returnType;
}
@after
{
	// If we consume any tokens at this point then we create
	// an ERRONEOUS AST node for the IDE to monitor and add it
	// in to the staement list.
	//
	if	(rPos != pos()) {
	
		if	($returnType != null) {
		
			// If we already had a return type, then
			// accumulate it, and the new error node
			// becomes the return value.
			//
			$stats.append($returnType);
		}
		
		// Span all the tokens we had to consume.
		//
		JFXErroneous errNode = F.at(rPos).Erroneous();
		endPos(errNode);
		$value = errNode;
				
		// Tell the script author where we think there is a screwed up expression
		//
		log.error(errNode, MsgSym.MESSAGE_JAVAFX_GARBLED_EXPRESSION);
	}
}
	:	// Deliberately match nothing, causing this rule always to be 
		// entered.
	;
	
// -----------------
// Block expression
// A single element (statement/expression etc) of a block, separated
// into it's own rule so that erroneous statements do not abort the
// entire block.
//
blockElement [JFXExpression val, ListBuffer<JFXExpression> stats]

returns [JFXExpression value] // All statements return an expression tree

@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
	// Ensure we capture the current return value of the statement on an
	// error.
	//
	boolean statCaptured = false;
}
	: s=statement 
		{	
			// If the current statement is not the first one
			// then append the previous on to the list so that this current one
			// becomes the return value for the block. This logic leaves us with 
			// the AST for the last non-erroneous statement in the block
			// in our val variable, which we need to build the
			// AST for the block when we reach its end.
			//
			if	($val != null) {
				$stats.append($val);
				statCaptured = true;
			}
			

			// The result of this rule becomes the type of the block, but
			// the caller will ensure that if this was an erroneous node,
			// that that does become the type of the block.
			//
			$value = $s.value;
		}
			possiblyOptSemi

	| SEMI	// Empty statements are just ignored, but the type must not be lost
	
		{ $value = $val; }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Ensure that we don't lose the prior statement that was currently
	// the return value of the block;
	//
	if	( !statCaptured && 	$val != null) {
		$stats.append($val);
	}
	
	// Create an erroneous node, which is basically an Erroneous node
	// masquerading as a JFXBlock.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -----------
// statements.
// Parse the set of elements that are viewed as programming statements. Note
// that this includes expressions, which are considered statements, or perhaps
// more accurately, statements are just other expressions.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, or whether this is optional, or whether this is
// conditionally optional, such as the last statement of the script or
// brace block.
//
statement


	returns [JFXExpression value] // All statements return an expression tree

@init
{	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: insertStatement		{ $value = $insertStatement.value; 								}
	| deleteStatement		{ $value = $deleteStatement.value; 								}
 	| whileStatement		{ $value = $whileStatement.value; 								}
        | (INVALIDATE expression)=>invalidateStatement		{ $value = $invalidateStatement.value; 								}
	| BREAK    				{ $value = F.at(pos($BREAK)).Break(null); 		endPos($value); }
	| CONTINUE  	 	 	{ $value = F.at(pos($CONTINUE)).Continue(null);	endPos($value); }
    | throwStatement	   	{ $value = $throwStatement.value; 								}
    | returnStatement 		{ $value = $returnStatement.value; 								}
    | tryStatement			{ $value = $tryStatement.value; 								}
    | expression			{ $value = $expression.value;									}
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Here, we can only have got junk, as badly formed statement elements
	// will be caught in their own rules.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }

// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

	returns [JFXOnReplace value]	// onReplace has its own JFX Tree node type

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: ON REPLACE oldv=paramNameOpt
						{ 
							if	($oldv.var != null)
							{
								errNodes.append($oldv.var);
							}
						}
	
		(
			  (
			  	LBRACKET 
			  		first=paramName 
						{ 
							errNodes.append($first.var);
						}
			  		DOTDOT 
			  		last=paramName 
						{ 
							errNodes.append($last.var);
						}
			  	RBRACKET
			  )?
			 
				 EQ newElements=paramName
						{ 
							errNodes.append($newElements.var);
						}
		)? 
		
	
		block [ -1 ]
		
		{ 
			// Build the appropriate AST
			//
			$value = F.at(pos($ON)).OnReplace($oldv.var, $first.var, $last.var, $newElements.var, $block.value);
			endPos($value); 
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Construct an erroneous version of the expected class
	//
	$value = F.at(rPos).ErroneousOnReplace(errNodes.elems);
	endPos($value);
	
}

// -----------
// ON INVALIDATE.
// Parse an ON INVALIDATE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onInvalidateClause

	returns [JFXOnReplace value]	// onReplace has its own JFX Tree node type

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: ON INVALIDATE block [ -1 ]
		{
			// Build the appropriate AST
			//
			$value = F.at(pos($ON)).OnInvalidate($block.value);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Construct an erroneous version of the expected class
	//
	$value = F.at(rPos).ErroneousOnInvalidate(errNodes.elems);
	endPos($value);

}
 
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

	returns [JFXVar var]	// Returns a JFXVar tree node

    : paramName
    	{
    		{ $var = $paramName.var; }
    	}
    
    |	{ $var = null; }
    ;
 
// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

	returns [JFXVar var]	// Returns a JFXVar tree node

	: pn=name
	 	{
    		
    		// The recovery mechanisms will auto generate the IDENTIFIER
			// token, in the case that it can predict that it was just a single
			// token that the programmer forgot to use. Hence we must
			// pick up on that and generate a different node for a Missing
			// identifier.
			//
			if ($pn.inError || $pn.value == null) {
			
			    $var = F.at($pn.pos).Param($pn.value, F.TypeUnknown()); 
			    endPos($var, pos());
			    
			} else {
			
			    $var = F.at($pn.pos).Param($pn.value, F.TypeUnknown()); 
			    endPos($var, $pn.pos + $pn.value.length());
			}
    	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
 }
    
// The ways in which a variable can be declared
//
variableLabel 
	
	returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
	
	: VAR			{ $modifiers = 0L; $pos = pos($VAR); }
	| DEF			{ $modifiers = JavafxFlags.IS_DEF; $pos = pos($DEF); }
	| ATTRIBUTE     { 	$modifiers = 0L; 
						$pos = pos($ATTRIBUTE); 
						JFXErroneous err = F.at($pos).Erroneous();
						endPos(err);
						log.error(err, MsgSym.MESSAGE_JAVAFX_NOT_SUPPORTED_ATTRIBUTE); 
					} 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	$modifiers = 0L;
	$pos = semiPos();
 }
 
// ------	
// Throw.
// Parse the standard exception throwing mechanism.
//
throwStatement

	returns [JFXExpression value]	// Returns the JFX Expression tree representing what we must throw
	
@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: THROW expression
	
		{ 
			// AST for the thrown expression
			//
			$value = F.at(pos($THROW)).Throw($expression.value);
			
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Now we need an error node
	//	
	$value = F.at(rPos).ErroneousThrow();
	endPos($value);
 }
 
// ---------------
// While statement
//
whileStatement
	
	returns [JFXExpression value]	// Returns the JFX Expression tree representing the WHILE
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: WHILE 
		LPAREN 
			expression 
				{
					errNodes.append($expression.value);
				}
		RPAREN 
	
		 loopVal=statement
			
		{
	
			// The AST for the WHILE, using either the block or statement
			//
			$value = F.at(pos($WHILE)).WhileLoop($expression.value, $loopVal.value);
			
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
 }
 
// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insertStatement  
	
	returns [JFXExpression value]	// All steatemetns return a JFX expression tree
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
}
	: INSERT elem=expression	{ errNodes.append($elem.value); }
	
		(
			  INTO eseq=expression
			  
			  	{
			  		errNodes.append($eseq.value);
			  		
			  		// Form 1, INTO
			  		//
					$value = F.at(pos($INSERT)).SequenceInsert($eseq.value, $elem.value, null, false);
			  	}
			  	
			| BEFORE isfi=indexedSequenceForInsert
			
				{
					if ($isfi.seq != null) errNodes.append($isfi.seq);
					if ($isfi.idx != null) errNodes.append($isfi.idx);
										
					// Form 2, BEFORE
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, false);
				}
				
			| AFTER isfi=indexedSequenceForInsert
			
				{
					if ($isfi.seq != null) errNodes.append($isfi.seq);
					if ($isfi.idx != null) errNodes.append($isfi.idx);
					
					// Form 3, AFTER
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, true);
				}
		)

		{
			// Tree span
			//
			endPos($value);
		}  
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
 }
 
// ----------------
// Insert seqeunce.
// Parse the syntax for an insert sequence specified by the 
// INSERT BEFORE and INSERT AFTER variants.
//
indexedSequenceForInsert

	returns [JFXExpression seq, JFXExpression idx]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: primaryExpression 			
	
		{
			// Sequence expression
			//
			$seq = $primaryExpression.value;
		}
		
	  LBRACKET expression 
	  
	  	{
	  		// Index expressions
	  		//
	  		$idx = $expression.value;
	  		errNodes.append($expression.value);
	  	}
	  	
	  RBRACKET
	  		
 	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Only index can throw us out here really
	// Create the erroneous node
	//
	$idx = F.at(rPos).Erroneous(errNodes.elems);
	endPos($idx);
 }
 
// -----------------	
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
deleteStatement  

	returns [JFXExpression value]	// Delete returns a JFX Expression tree
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: DELETE e1=expression
	
		{
			errNodes.append($e1.value);
		}

	   ( 
	   		  (FROM)=>FROM e2=expression
	   		  	
	   		  	{
	   		  		$value = F.at(pos($DELETE)).SequenceDelete($e2.value,$e1.value);
	   		  	}
	   		  	
	   		| /* indexed and whole cases */
	   		
	   			{
	   				$value = F.at(pos($DELETE)).SequenceDelete($e1.value);
	   			}
	   			
	   )
	   
	   {
	   		// Tree span
	   		//
	   		endPos($value);
	   }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
 }

// -----------------
// INVALIDATE statement.
// Parse the INVALIDATE statement forms and return the appropriate AST
//
invalidateStatement

	returns [JFXExpression value]	// Delete returns a JFX Expression tree

@init
{

	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: INVALIDATE e1=expression

            {
                    $value = F.at(pos($INVALIDATE)).Invalidate($e1.value);
            }
	;
// Catch an error. We create an erroneous node for anything that was at the start
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
returnStatement

	returns [JFXExpression value]	// RETURN returns a JFX Expression tree
@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: RETURN 
		
		(
			  expression		
			  
			  	{	
			  		$value = F.at(pos($RETURN)).Return($expression.value);	
			  	}
			  	
			| (possiblyOptSemi)=>possiblyOptSemi	// Can't have a SEMI be optional here as we must eitehr consume
													// the next expression or not.
				{	
					$value = F.at(pos($RETURN)).Return(null);				
				}
				
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
//
tryStatement

	returns [JFXExpression value]	// returns a JFX Expression tree
	
@init
{
	// AST for any catch clauses
	//
	ListBuffer<JFXCatch> caught = ListBuffer.lb();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
	// Count the number of finally clauses
	//
	int	finallyCount = 0;
	
	// Count the number of catch clauses
	//
	int catchCount = 0;
	
	// Only error out on finally/catch out of sequence fo rthe first out
	// of sequence error.
	//
	boolean showSequenceErr = true;
	
	// Record start postion of finally clauses for correct error
	// position.
	//
	int fPos = 0;
	
}
	: TRY block [-1]
			{ 
				errNodes.append($block.value); 
			}
		( 
		
			// Predicate is neccessary to disambiguate associated catch and finally
			// blocks from orphaned blocks handled in alts 2 and 3 of the main rule
			//
			(CATCH|FINALLY)=>
		
			(
				  { 
					// Record input positoni in case of error.
					//
					fPos = pos();
				  }
		 	  		f1=finallyClause	
		 	  		
		 	  		{ 
		 	  			errNodes.append($f1.value); 
		 	  		
		 	  			if	(finallyCount != 0) {
		 	  		
		 	  				// Can only have one finally clause, so log an error
		 	  				//
			   				log.error($f1.value, MsgSym.MESSAGE_JAVAFX_FINALLY_TOOMANY);
		 	  			}
		 	  			finallyCount++; 
		 	  		}
		 	  
	   			| (
	   				catchClause
	   				
	   				{
	   					if	(finallyCount != 0 && showSequenceErr)	{
	   					
	   						// We came across a catchClause, but we have already seen the finally clause.
	   						// We only error out the first time we detect the error so we don't throw
	   						// the same error for each catch clause that is out of order.
	   						//
	   						showSequenceErr = false;
				   			log.error($f1.value, MsgSym.MESSAGE_JAVAFX_FINALLY_NOTLAST);
	   					}
	   					// Accumulate the catch clauses
	   					//
	   					caught.append($catchClause.value);
	   					errNodes.append($catchClause.value);
	   					catchCount++;
	   				}
	   		  	  )					
	   		) 
	   	)*
	   	
	   	{
	   		// Now - check for malformed constructs and make the AST node or the
	   		// erroneous node as appropriate
	   		//
	   		if	(catchCount == 0 && finallyCount == 0)
	   		{
	   			// We must see at least one catch or one finally, or we can't build
	   			// the AST
	   			//
	   			$value = F.at(pos($TRY)).Erroneous(errNodes.elems);
	   			endPos($value);
	   			log.error($value, MsgSym.MESSAGE_JAVAFX_BAD_TRY);
	   			
	   		} else {
	   		
		   		// Build the AST
		   		//
		   		$value = F.at(pos($TRY)).Try($block.value, caught.toList(), $f1.value);
	   		
	   			// Tree span
	   			//
	   			endPos($value);
	   		}
	   	}
	
		// Erroneouds constructs
		//
	|	fe=finallyClause
	
			{
				// Dangling finally clause belongs to no try block
				//
				errNodes.append($fe.value);
	   			$value = F.at(rPos).Erroneous(errNodes.elems);
	   			endPos($value);
	   			log.error($value, MsgSym.MESSAGE_JAVAFX_ORPHANED_FINALLY);
			}
			
	|	ce=catchClause

			{
				// Dangling catch clause belongs to no try block
				//
				errNodes.append($ce.value);
	   			$value = F.at(rPos).Erroneous(errNodes.elems);
	   			endPos($value);
	   			log.error($value, MsgSym.MESSAGE_JAVAFX_ORPHANED_CATCH);
			}

	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//

finallyClause

	returns [JFXBlock value] // returns a JFX Expression tree

@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: FINALLY block [rPos]
	
		{
			$value = $block.value;
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// The only thing we can have happen is that there was no block, so there
	// can be no nodes to catch
	//
	$value = F.at(rPos).ErroneousBlock();
	endPos($value);
}
 
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause

	returns [JFXCatch value]	// Catch has its own JFX tree node type

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: CATCH 
		LPAREN 
			formalParameter 
				{
					errNodes.append($formalParameter.var);
				}
		RPAREN 
			block[-1]
	
		{
			$value = F.at(pos($CATCH)).Catch($formalParameter.var, $block.value);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Errnoeous node
	//
	$value = F.at(rPos).ErroneousCatch(errNodes.elems);
	endPos($value);
}
 
// ---------------------
// Boundable expression.
// Used to parse expressions that can be bound to a variable.
//
boundExpression 

	returns [JavafxBindStatus status, JFXExpression value] 	// We nede to return a status flag to say how and if the
															// expression is bound, and the AST for the expression itself.

@init 
{ 
	boolean isBidirectional	= false; 	// Signals presence of INVERSE

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: BIND 
	  
      ( LAZY
			{
				// Ignore
				//TODO: warning
			}
	  )?
	  
	  e1=expression 
	
		{
			errNodes.append($e1.value);	// For erroneous node
		}
	
			(
				(WITH)=>WITH 
				
					// Future syntax: (expression AS)?
				
					 INVERSE
				
				{
					// Update status
					//
					isBidirectional = true;
				}
			)?
			
			{
				// Set up the bound expression
				//
				$value	= $e1.value;
				
				// Update the status
				//
				$status	= isBidirectional? BIDIBIND : UNIDIBIND;
			}
	
	| e2=expression
	
		{
			// Unbound expression AST
			//
			$value 	= $e2.value;
			
			// Update the status
			//
			$status	= UNBOUND;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
   	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Signal as if unbound
	//
	$status	= UNBOUND;
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	
	// We discovered nothing in the list and so the endpos
	// is the same as the rule start position.
	endPos($value);
}

// -----------
// expression.
// General expression parse and AST build.
//
expression

	returns [JFXExpression value]	// Expression has its own dedicated JFX tree node type
 
 @init
 {
 	// Used for error reporting
 	//
 	int rPos = pos();
 }
	: ifExpression

		{
			$value = $ifExpression.value;
		}
				
	| forExpression   	

		{
			$value = $forExpression.value;
		}
		

		
	| assignmentExpression

		{
			$value = $assignmentExpression.value;
		}
		
	| // Expressions can parse varaible declarations at all levels
	  // both local, script, class etc. It is up to the attribution phase
	  // to throw out modifiers where they are not allowed such as on 
	  // local variable declarations.
	  //
	  m=modifiers 
	   	
	  	variableDeclaration [$m.mods, $m.pos]
	
		{
			$value = $variableDeclaration.value;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// An error at this point in the expression tree means we
	// will not have anythig to accumulate for an erroneous node
	// so we span from the start to the recovery point.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
}

// ------------------------
// FOR statement/expression
//
forExpression

	returns [JFXExpression value]	// All statements are expressions

@init
{
	// In clause accumulator
	//
	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

 	// Used for error reporting
 	//
 	int rPos = pos();

}
	: FOR 
		LPAREN 
		
			i1=inClause			
				{  
					clauses.append($i1.value); 
					errNodes.append($i1.value); // For erroneous node
				}
			(COMMA i2=inClause	
					{  
						clauses.append($i2.value); 
						errNodes.append($i2.value); // For erroneous node
					} 
			)* 
			
		RPAREN 
		
		statement
				
			{
				errNodes.append($statement.value); 
		 		$value = F.at(pos($FOR)).ForExpression(clauses.toList(), $statement.value);
			}
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Though we seemed to start out down a FOR statement, there was an error
	// that we could not recover from by simple insert/delete token, so we
	// span the erroneous trees
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause

	returns [JFXForExpressionInClause value]	// Dedicated AST tree node

@init
{
	// Assume no WHERE expression
	//
	JFXExpression weVal = null;
	
	// Start postion
	//
	int sPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: formalParameter 	{ errNodes.append($formalParameter.var); 	}
		IN 
		se=expression 	{ errNodes.append($se.value);				}
	
		(
			  WHERE we=expression	{ weVal = $we.value; errNodes.append($we.value); }
			|
		)
		
		{
			$value = F.at(sPos).InClause($formalParameter.var, $se.value, weVal);
			endPos($value); 
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// But we create an Erroneous version of the node
	//
	$value = F.at(sPos).ErroneousInClause(errNodes.elems);
	endPos($value);
}

// -----------------------
// If Then Else expression
//
ifExpression 

	returns [JFXExpression value]	// The expression tree that represents the If expression
	
@init
{
	// Statement or block expression
	//
	JFXExpression sVal = null;
	
	// Else expression (if present)
	//
	JFXExpression eVal = null;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
 	// Used for error reporting
 	//
 	int rPos = pos();

}
	: IF LPAREN 
	
			econd=expression  	{ errNodes.append($econd.value);	}
			
		RPAREN 
	

		THEN?  statement 			{ sVal = $statement.value;	errNodes.append(sVal);	}
			
			(
				(ELSE)=>e1=elseClause	{ eVal = $e1.value;	errNodes.append(eVal);	}
			)?
			
		{
			// The IF AST
			//
			$value = F.at(pos($IF)).Conditional($econd.value, sVal, eVal);
			
			// Tree span
			//
			endPos($value);
			
		}
		
	| // Deliberately allow an orphaned else (non-orphaned ones will be
	  // pick ed up by the IF clause above) so it can be parsed an attributed
	  // for the AST (downstream tools may require this), but then throw it
	  // out as being orphaned.
	  //
	  ee=elseClause
	  
	  	{
	  		// Accumulate for the error node
	  		//
	  		errNodes.append($ee.value);
	  		$value = F.at(rPos).Erroneous(errNodes.elems);
	  		endPos($value);
	  		
	  		// Tell the script author (and the IDE) about their issue
	  		//
	  		log.error($value, MsgSym.MESSAGE_JAVAFX_ORPHANED_ELSE);
	  	}
	
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// But we create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -----------
// Else clause
// Parse the else expression of an if statement
//
elseClause

	returns [JFXExpression value]	// The expression tree that represents the Else expression
@init
{
	// Used for error productiions
	//
	int	rPos = pos();
}
	: ELSE 
		(
			statement			{ $value = $statement.value; 	}
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// We can only get an error here if we had an ELSE clause but
	// the statement was missing or we could not reach it for too much 
	// junk, so nothing to put in the errornode
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
}	

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: lhs=assignmentOpExpression 
			{
				errNodes.append($lhs.value);	// For error production
			}
		(     
			  (EQ)=> EQ rhs=expression
			  
			  	{
			  		// This is actually an assign
			  		//
			  		$value = F.at(rPos).Assign($lhs.value, $rhs.value);
			  		
			  		// Tree span
			  		//
			  		endPos($value);
			  	}
			  	
			|	// Just an expression without an assignment
				//
				{
					$value = $lhs.value;
				}
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

assignmentOpExpression

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	: lhs=orExpression			{ errNodes.append($lhs.value); }		
	  
		(     assignOp rhs=expression
		
				{
					// AST for assignement
					//
					$value = F.at(rPos).Assignop($assignOp.op, $lhs.value, $rhs.value);
				}
				
           	| SUCHTHAT 
           		such=orExpression { errNodes.append($such.value); }
           	
           			(
           				(TWEEN)=>TWEEN i=orExpression
           			)?
           	
           		{
           			// AST FOR Interpolation
           			//
           			$value = F.at(rPos).InterpolateValue($lhs.value, $such.value, $i.value);
           			
           		}
           	
	   		|	{ 
	   				// AST for expressions
	   				//
	   				$value = $lhs.value; 
	   			}	
	   )
	   
	   {
	   		// AST Span
	   		//
	   		endPos($value);
	   }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
}

// -----------------
// Assign operators
// All the operators that involve assignments.
//	
assignOp

	returns	[JavafxTag op]	// Returns the operation token that we find
	
	: PLUSEQ		{ $op = JavafxTag.PLUS_ASG; 			}
	| SUBEQ			{ $op = JavafxTag.MINUS_ASG;			}
	| STAREQ		{ $op = JavafxTag.MUL_ASG;              }
	| SLASHEQ		{ $op = JavafxTag.DIV_ASG;				}
	| PERCENTEQ
		{ 
			// Create an error node for a DiagnosticPosition
			//
			JFXErroneous err = F.at(pos($PERCENTEQ)).Erroneous();
			endPos(err);
			log.error(err, MsgSym.MESSAGE_JAVAFX_BAD_PERCENT);
			
			// Erroneous operator
			//
			$op = JavafxTag.ERRONEOUS;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// -------------
// OR opertator
// LL(k) OR precedence
//
orExpression

	returns [JFXExpression value] 	// Expression tree for OR
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	:	e1=andExpression
			
			{
				$value = $e1.value;
				errNodes.append($e1.value);
			}
	  		( 
	  			OR e2=andExpression
	  			
	  			{
	  				$value = F.at(rPos).Binary(JavafxTag.OR, $value, $e2.value);
	  				endPos($value);
	  			}
	  		)*
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -----------
// AND operator
// LL(k) AND precedence
//
andExpression

	returns [JFXExpression value] 	// Expression tree for AND
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: e1=typeExpression

		{
			$value = $e1.value;
			errNodes.append($e1.value);
		}
	  	( 
	  		AND e2=typeExpression 
	  		
	  		{
	  			$value = F.at(rPos).Binary(JavafxTag.AND, $value, $e2.value);
	  			endPos($value);
	  		}
	  	)*
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: relationalExpression		{ errNodes.append($relationalExpression.value); }

		(
			  INSTANCEOF itn=type
			
				{
					$value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
					endPos($value);
				}
				
			| AS atn=type
			
				{
					$value = F.at($relationalExpression.value.pos).TypeCast($atn.rtype, $relationalExpression.value);
					endPos($value);
				}
			
			| 	{
					$value = $relationalExpression.value;
				}
	   )
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// -----------
// Relationals
// LL(k) precedence
//	
relationalExpression  

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: a1=additiveExpression	{ $value = $a1.value; errNodes.append($a1.value); }
		(
			
			relOps   a2=additiveExpression
			  	
			  	{
			  		$value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
			  		endPos($value);
			  	}
		)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

	returns [JavafxTag relOp]	// Returns the JFX operator type
	
	: LTGT
		{ 
			JFXErroneous err = F.at(pos($LTGT)).Erroneous();
			endPos(err);
			$relOp = JavafxTag.NE;
			log.error(err, MsgSym.MESSAGE_JAVAFX_NOT_NE);
		}	
			  		
	| NOTEQ  { $relOp = JavafxTag.NE;	}
	| EQEQ   { $relOp = JavafxTag.EQ;	}
	| LTEQ   { $relOp = JavafxTag.LE;	}
	| GTEQ   { $relOp = JavafxTag.GE;	}
	| LT     { $relOp = JavafxTag.LT;	}
	| GT     { $relOp = JavafxTag.GT;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//	
additiveExpression 

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
	: m1=multiplicativeExpression	
		{ 
			$value = $m1.value; 
			errNodes.append($m1.value);
		}
		(
		    (arithOps)=>
		    	
		    	arithOps   m2=multiplicativeExpression

			{
				$value = F.at(rPos).Binary($arithOps.arithOp , $value, $m2.value);
				endPos($value);
			}
		)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// --------------------
// Arithmetic operators
//
arithOps

	returns [JavafxTag arithOp]	// Returns the JFX operator type
	
	: PLUS		{ $arithOp = JavafxTag.PLUS; 	}
	| SUB		{ $arithOp = JavafxTag.MINUS;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//	
multiplicativeExpression

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
	: u1=unaryExpression	{ $value = $u1.value; errNodes.append($u1.value); }
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			multOps u2=unaryExpression
				
				{
					$value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
					endPos($value);
				}
	   )* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

	returns [JavafxTag multOp]	// Returns the JFX operator type
	
	: STAR    	{ $multOp = JavafxTag.MUL;	}
	| SLASH   	{ $multOp = JavafxTag.DIV;	}
	| PERCENT 	
			
		{
			JFXErroneous err = F.at(pos($PERCENT)).Erroneous();
			endPos(err);
			$multOp = JavafxTag.MOD;
			log.error(err, MsgSym.MESSAGE_JAVAFX_BAD_PERCENT);
		}	
             
	| MOD		{ $multOp = JavafxTag.MOD;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

}

// -----------------	
// Unary expressions
// LL(k) Precedence
//
unaryExpression

	returns [JFXExpression value] 	// Expression tree for unary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: se=suffixedExpression

		{
			errNodes.append($se.value);
			$value = $se.value;
		}
		
	| INDEXOF		id=identifier
	
		{ 	
			$value = F.at(rPos).Indexof($id.value);
			endPos($value);
		}
		
	| (SUB DECIMAL_LITERAL)=> SUB        DECIMAL_LITERAL

		{
			$value = F.at(rPos).LiteralInteger('-' + $DECIMAL_LITERAL.text, 10);
			endPos($value);
		}

	| unaryOps     	e=unaryExpression

		{
			$value = F.at(rPos).Unary($unaryOps.unOp, $e.value);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps

	returns [JavafxTag unOp]	// Returns the JFX operator type
	
	: SUB			{ $unOp = JavafxTag.NEG; }
	| NOT			{ $unOp = JavafxTag.NOT; }
	| SIZEOF		{ $unOp = JavafxTag.SIZEOF; }
	| PLUSPLUS		{ $unOp = JavafxTag.PREINC; }
	| SUBSUB		{ $unOp = JavafxTag.PREDEC; }
	| REVERSE		{ $unOp = JavafxTag.REVERSE; }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: pe=postfixExpression	{ errNodes.append($pe.value); }
		( 
			  { input.LT(-1).getType() != RBRACE }?=> PLUSPLUS
			  
			  	{
			  		$value = F.at(rPos).Unary(JavafxTag.POSTINC, $pe.value);
			  		endPos($value);
			  	}
			  	
			| { input.LT(-1).getType() != RBRACE }?=> SUBSUB
			
				{
					$value = F.at(rPos).Unary(JavafxTag.POSTDEC, $pe.value);
					endPos($value);
				}
				
			| { $value = $pe.value; }
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ------------------------
// Postfix-able expressions
// LL(k) precedence
//
postfixExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	int	sPos = rPos;

	// Position for pipe epxression
	//
	int pPos = -1;
	
	// Indicates if we had the LT token
	//
	int clusiveType = SequenceSliceTree.END_INCLUSIVE;
	
	// Last element of sequence (if present)
	//
	JFXExpression	lastExpr = null;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: pe=primaryExpression	{ $value = $pe.value; errNodes.append($pe.value); }
	
		(
			  DOT 
				( 
				      (CLASS)=>CLASS 
					
						{
							Name cName = Name.fromString(names, "class"); 
							$value = F.at(pos($DOT)).Select($value, cName);
							endPos($value);
							errNodes.append($value);
					  	}
					  	
					| n1=nameAll
					  
					  {
							$value = F.at(pos($DOT)).Select($value, $n1.value);
							endPos($value);
							errNodes.append($value);
					  }
					   
	         	)

			| (LPAREN)=>LPAREN 

					expressionList 
			
				{
					$value = F.at(sPos).Apply(null, $value, $expressionList.args.toList());
					errNodes.append($value);
					
				}
				RPAREN
				{
					endPos($value);
				}
				
			| (LBRACKET)=>l1=LBRACKET
			
				{
					// INit our flags
					//
					clusiveType = SequenceSliceTree.END_INCLUSIVE;
					lastExpr 	= null;
				}
	
				(
					  n2=name 
					  	{
					  		// Build up new node in case of error
							//
							JFXExpression part = F.at($n2.pos).Ident($n2.value);
							errNodes.append(part);
							endPos(part);
                            pPos = part.getEndPosition(endPositions);
						}
					  
					  PIPE 
					  
					  { rPos = pos(); }	// Use expression as position for AST
					  
					  e1=expression r3=RBRACKET
					  
					  {
					  	errNodes.append($e1.value);
					  	
					  	// Build a list of clauses as AST builder expects this
					  	//
					  	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();
                  		
                  		// Build a var reference
                  		//
                  		JFXVar var = F.at($n2.pos).Param($n2.value, F.TypeUnknown());
                        endPos(var, pPos);
                  		
                  		// Set up the in clause
                  		//
	          			clauses.append(F.at(pos($l1)).InClause(var, $value, $e1.value));
	          			
	          			// Predicate needs identifier AST
	          			//
                  		$value = F.at(sPos).Predicate(clauses.toList(), F.at($n2.pos).Ident($n2.value));
                  		
                  		// Tree span
                  		//
                  		endPos($value, pos($r3));
					  }
					  
					| first=expression	{ errNodes.append($first.value); }
                            
						(
							  r1=RBRACKET
							  
							  	{
							  		// Use left bracket as AST start pos
							  		//
							  		$value = F.at(sPos).SequenceIndexed($value, $first.value);
							  		
							  		// Use right bracket as AST end pos
							  		//
							  		endPos($value);
							  	}
							  	
	                    	| DOTDOT 
	                    		(
									  (LT { clusiveType = SequenceSliceTree.END_EXCLUSIVE; } )? 
									  	(
									  		last=expression
									  		{
									  			errNodes.append($last.value);
									  			lastExpr = $last.value;
									  		}
									  	)?
									  	
								)
								
	                      	  r2=RBRACKET
	                      	  
	                      	  {
	                      	  	// If we have LT, then this is an exclusive slice
	                      	  	//
	                      	  	$value = F.at(sPos).SequenceSlice
	                      	  									(
	                      	  										$value,
	                      	  										$first.value,
	                      	  										lastExpr,
	                                                            	clusiveType
	                                                            );
								endPos($value);
	                      	  }
                    	)
             	)
	   	)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//	
primaryExpression  

	returns [JFXExpression value] 	// Expression tree for primary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Use to build a list of objectLiteral parts.
	//
	ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb();

    // Used to construct time literal expression
    //
    JFXExpression sVal = null;

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();	
}
	: qualname
		{
			$value = $qualname.value;
			errNodes.append($value);
		}
		(
			(LBRACE)=>LBRACE  
			  	
					o1=objectLiteral
					
			RBRACE
	              
				{
					// AST
					//
					$value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
					
					// Tree span
					//
					endPos($value);
				}
			|
		)

	| THIS

		{
			$value = F.at(pos($THIS)).Ident(names._this);
			endPos($value);
		}
		
	| SUPER
	
		{
			$value = F.at(pos($SUPER)).Ident(names._super);
			endPos($value);
		}
		
	| se=stringExpression

		{
			$value = $se.value;
		}
		
	| be=bracketExpression
	
		{
			$value = $be.value;
		}
		
	| block [-1]
	
		{
			$value = $block.value;
		}
		
	| literal
	
		{
			$value = $literal.value;
		}
		
	| fe=functionExpression
	
		{
			$value = $fe.value;
		}
	
	| LPAREN e=expression RPAREN
	
		{
			$value = preserveTrees ?
                            F.at(pos($LPAREN)).Parens($e.value) :
                            $e.value;
            endPos($value);
		}
		
	| AT 
		LPAREN 
			tv=timeValue
            {
                sVal = $tv.valNode;
                errNodes.append($tv.valNode);
            }
		RPAREN 
		LBRACE 
			k=keyFrameLiteralPart

		RBRACE
		
		{
            $value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);
			endPos($value);
		}
	
	| newExpression

		{
			$value = $newExpression.value;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// If we were constructing an object literal or keyframe set, then
	// we will still create that, but an error node will have been added
	// to containing block or if there is no containindg block, the script
	//
	if	($o1.parts != null) {
	
		$value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
	
	} else if ($tv.valNode != null && $k.exprs != null) {

		$value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);

	} else {
		// Create an Erroneous version of the node
		//
		$value = F.at(rPos).Erroneous(errNodes.elems);

	}
			
	endPos($value);	
			
}

// ------------
// Frame values
//  
keyFrameLiteralPart

	returns [ListBuffer<JFXExpression> exprs = new ListBuffer<JFXExpression>(); ]	// Gathers a list of expressions representing frame values
	
	// Where to append erroneous nodes
	//
	scope errorStack;
	
@init
{

	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	$errorStack::ASTErrors = exprs;
	
}
	: k1=expression 			{ exprs.append($k1.value);	}
	
		(SEMI SEMI* // This is a trick to force error recovery, otherwise SEMI+ forces an early exit exception
		
			k2=expression		{ exprs.append($k2.value);	}
		)* SEMI*
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Any error messages will auto accumulate and erroneous node, so
	// we need do nothing here.
}

// -------------------
// Anonymous functions
//
functionExpression

	returns [JFXExpression value] 	// Expression tree for anonymous function
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
	
}
	: FUNCTION 
	
		formalParameters 	
			{ 
				// Accumulate in case of error
				//
				for	( JFXTree t : $formalParameters.params) {
					errNodes.append(t);
				}
			}
			
		typeReference 	{ errNodes.append($typeReference.rtype); }
		block	[-1]	{ errNodes.append($block.value); }
	
		{
			// JFX AST
			//
			$value = F.at(pos($FUNCTION)).FunctionValue
								(
									$typeReference.rtype, 
									$formalParameters.params.toList(),
									$block.value
								);
								
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS vode
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ---
// NEW
//
newExpression

	returns [JFXExpression value] 	// Expression tree for new expression

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
}
	: NEW 
		typeName 				{ errNodes.append($typeName.value); }
		expressionListOpt
	
		{
			// If we got ehre, there wil lbe no errors for expressionListOpt, and if 
			// did not, then the expressionListOpt will not be built, so we do not accumulate
			// its nodes for error.
			//
			$value = F.at(pos($NEW)).InstanciateNew($typeName.value, $expressionListOpt.args.toList());
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an ERRONEOUS vode
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ---------------
// Object literals
//
objectLiteral

	returns [ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb()]	// Gather a list of all the object literal insitalizations

// Where to append erroneous nodes
//
scope errorStack;

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	$errorStack::ASTErrors = parts;
	
	// Rule pos in case of error
	//
	int	rPos = pos();
}
	:   (COMMA|SEMI)*	// Separators are optional and just syntactic sugar
	
		(		
			(
				oli=objectLiteralPart 
			
				{
					parts.append($oli.value);
				}
			)
			
			(COMMA|SEMI)*	// Separators are optional and just syntactic sugar
			
			
		)*		// May be no elements in the object literal, just {}
	
				
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// The error message routines will have accumulated
	// any erroneous nodes, so we don't need ot do anythign here
	// but return. We don't want to throw the whole set into
	// error as we can be finer grained.
	//
	
}

// Individual components of an object literal
//
objectLiteralPart

	returns [JFXTree value] 	// Expression tree for object literal elements

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
	
}
	: modifiers
		(
			  variableDeclaration    [$modifiers.mods, $modifiers.pos]
			  
			  	{
			  		$value = $variableDeclaration.value;
			  		errNodes.append($value);
			  	}
			  	
			| functionDefinition	 [$modifiers.mods, $modifiers.pos]
			
				{
					$value = $functionDefinition.value;
					errNodes.append($value);
				}
		)
		
	| oli=objectLiteralInit
		
		{
			$value = $oli.value;
			errNodes.append($oli.value);
		}
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// --------------------------     	
// Object literal initializer
//	
objectLiteralInit

	returns [JFXTree value]		// Construct the AST for a name value pair
	
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Indicates that something went wrong with the parse
	//
	boolean	inError = false;
}
	: n1=name
		{
			if	($n1.inError || $n1.value == null) {
				
				// The rule caused an identifier to be made up
				//
				inError = true;
			}
							
			// Build up new node in case of error
			//
			JFXExpression part = F.at($n1.pos).Ident($n1.value);
			errNodes.append(part);
			endPos(part);
		} 
		COLON  
		boundExpression
	
		{
			if	(inError) {
			
				// Missing name, so throw this into error state
				//
				errNodes.append($boundExpression.value);
				
				// Create an ERRONEOUS node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				
			} else {
			
				// AST
				//
				$value = F.at($n1.pos).ObjectLiteralPart
										(
											$n1.value,
									 		$boundExpression.value, 
									 		$boundExpression.status
									 	);
			}
							 	
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	

}

// -------	
// Strings
// JavaFX string expressions are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time,
//    which gives the script author unambiguous control over
//    leading spaces, explict methods to insert new lines, and the ability to comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leads to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Compound parts cannot be translated individually;
//
stringExpression 

	returns [JFXExpression value] 	// Expression tree for stringExpressions

scope {
	// Indicates that the expression went into a parse error state
	// somehere and we should not try to resolve it
	//
	boolean inError;
}

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> strexp = new ListBuffer<JFXExpression>();
	
	// Translation key, if any, for the literal string
	//
    String translationKey = null;
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start in non error state
	//
	$stringExpression::inError = false;
	
}

	: (
		  (
			// Translation key is optional
		  	//
		  	TRANSLATION_KEY	{ translationKey = $TRANSLATION_KEY.text; } 
		  )?
	
			// We must find at least one compound element to the string
			//
			strCompoundElement [ strexp ]
			
			(
				// After the first element, there may be any number of additional
				// elements, including zero. We must force the parser to take
				// the righteous path for syntactically correct constructs, then
				// error out semantically on anything else.
				//
				   (STRING_LITERAL|QUOTE_LBRACE_STRING_LITERAL) =>strCompoundElement [ strexp ]
			
			)*
	  )
	  
		{
			if	($stringExpression::inError) {
			
				// Some part of this parse caused an error, so the whole lot just
				// accumulates into an error node.
				//
			
				// Accumulate whatever pieces we discovered
				//
				for	(JFXTree t : strexp) {
	
					errNodes.append(t);
				}
	
				// Create an ERRONEOUS node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				endPos($value);	
	
			} else {
			
	  			// AST for string expression
	  			// If we accumulated just a single entry then by definition
	  			// we accumulated just a simple string literal, but if there
	  			// is more than one entry, or there is a translation key,
	  			// then we have a string expression
	  			//
	  			if	(strexp.size() > 1 || translationKey != null)
				{
					// Complex expression
					//
		  			$value = F.at(rPos).StringExpression(strexp.toList(), translationKey);
	
					// Tree span
	  				//
	  				endPos($value);
	
	  			}
		  		else
		  		{
		  			// This is an individual string literal, and is already endPos'ed
		  			//
		  			$value  = strexp.toList().get(0);
				}
			}  			
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Accumulate whatever pieces we discovered
	//
	for	(JFXTree t : strexp) {
	
		errNodes.append(t);
	}
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
	
}

// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<JFXExpression> strexp ]
	
	: stringLiteral	[ strexp ]	  		
	| qlsl 			[ strexp ]
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// ---------------
// String literals
// We may have multiple string literals following each
// other, which we auto concatentate here at compile time
//
//
stringLiteral [ ListBuffer<JFXExpression> strexp ]


@init
{
	// Record position of invalid expression used in compile time
	// string compounding.
	//
	int ePos;
	
	// Used to accumulate multiple string literals
	//
	StringBuffer sbLit = new StringBuffer();
	
	// The string litereal we will created
	//
	JFXExpression sVal = null;

}
	: s1=STRING_LITERAL 
	
		{
			// Accumulate the literal
			//
			sbLit.append($s1.text);
		}
	
		(
			(STRING_LITERAL)=> s2=STRING_LITERAL
			
			{
				// Accumulate the literal
				//
				sbLit.append($s2.text);
			}
		)*
		
		{

			// Here, one of the following conditions prevails
			//
			//  i)  We have as yet encountered no components of the compound
			//      string and so we can assume for the moment that the literal
			//      string elements we have accumulated so far will remain as
			//	    a simple string literal, and so just add the literal we
			//	    make as one element.
			// ii)  There has already been some sort of compound expression
			//      in which case there will be more than 0 elements currently in
			//      the compound element list. The list will always be left with
			//      the trailing part of the expression string as the last element
			//      of the list as it is built of "leading{\%format expr}trailing".
			//      So, we can remove the last entry, append this newly accumulated
			//      string literal to it, and move on.
			//
			if	( $stringExpression::inError || strexp.size() == 0)
			{
			
				// Now we create the actual string literal
				//
				sVal = F.at(pos($s1)).Literal(TypeTags.CLASS, sbLit.toString());
			
				// Add to list
				//
				strexp.append(sVal);

				// Tree span
				//
				endPos(sVal);
			
			}
			else
			{
				// Already had the first expression, replace the traling part of the
				// last expression with a concatenation of it and this newly found
				// string.
				//
				JFXLiteral trailer = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
				
				// Now, append the string we have to the prior trailing part
				// 
				sbLit.insert(0, (String)(trailer.getValue()));
				
				// Replace the original value
				//
				trailer.value = sbLit.toString();
				
			}

		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;
	
}
	
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<JFXExpression> strexp]

	: 	ql=QUOTE_LBRACE_STRING_LITERAL	
	
			{
				if	($stringExpression::inError) {
				
					// Add the leadin string
					//
					JFXLiteral leader = F.at(pos($ql)).Literal
											(	TypeTags.CLASS,
											 	$ql.text
											);
					endPos(leader);
	
					// Add it in to the list
					//
					strexp.append(leader);
							
				} else {
					// Add in the discovered literal value
					//
					// Here, one of the following conditions apply:
					//
					//   i) There are currently no entries in the buffer. The size of strexp
					//      will be 0 in that case and we can process the expression without 
					//      regard to prior values.
					//  ii) There was one or leading string literals (non expressions),
					//      in which case the list buffer size will be 1, representing
					//      the accumulated string literal. In that case we must append
					//	    the leadin string ($ql above) to the existing string and make
					//      it the leadin for this expression.
					// iii) There were prior expressions in the list, in which case, as per
					//      ii) we must merge the last literal in the buffer with ($ql) from
					//      above and make it the leadin string for this expression.
					//      NB: THis can only arise from "{expr}" ("STRING")* "{expr}"
					//
					switch	(strexp.size())
					{
						case 0:
				
							// Add the leadin string
							//
							JFXLiteral leader = F.at(pos($ql)).Literal
												(	TypeTags.CLASS,
												 	$ql.text
												);
							endPos(leader);
	
							// Add it in to the list
							//
							strexp.append(leader);
							
							break;	
	
					default:
						
							// Already had a single first literal, or a trailer for an 
							// expression - make it belong to this leader.
							//
							leader = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
					
							// Now, append the string we have to the prior trailing part
							// and replace the original value
							//
							leader.value = (String)(leader.getValue()) + $ql.text;
							break;
					}
				}
			}
			
		// Optional string format
		//
	    stringFormat	[strexp]
	    
	    // An expression to evaluate at runtime
	    // 
	  	e2=expression 					{ strexp.append($e2.value);	}
	  
	  	// Any number of inner elements
	  	//
	  	( stringExpressionInner [strexp]  )*   
	  
	  	// The last component of the {} enclosing string literal
	  	//
	  	qr=RBRACE_QUOTE_STRING_LITERAL
	  
	  		{
	  			// Add in the discovered literal
	  			//
	  			JFXLiteral trailer = F.at(pos($qr)).Literal
											(	TypeTags.CLASS,
											 	$qr.text
											);
				endPos(trailer);
				
				// Add to the list
				//
				strexp.append(trailer);	
			}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<JFXExpression> strexp]

	: rlsl=RBRACE_LBRACE_STRING_LITERAL 
	
		{
			// Construct a new literal for the leading literal
			//
			JFXExpression rb = F.at(pos($rlsl)).Literal(TypeTags.CLASS, $rlsl.text);
			
			// Record the span
			//
			endPos(rb);
			
			// Add the literal to the list
			//
			strexp.append(rb);
			
		}
		
		// Deal with the string format
		//
		stringFormat[strexp] 
		
		// Expression to evaluate at runtime
		//
		expression
		
		{
			strexp.append($expression.value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// --------------------
// Format specification
// Optional format specifier in standard Java form
//
stringFormat [ ListBuffer<JFXExpression> strexp]

@init
{
	// The value to add in to the mix
	//
	JFXExpression value;
	
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: fs=FORMAT_STRING_LITERAL
	
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, $fs.text);
			endPos(value);
			strexp.append(value);
		}
		
	| // no format
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, "");
			endPos(value, rPos);	// Needs to be shown as a non-existant string to the IDE
			strexp.append(value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}
	
// ---------------------------
// Sequence
// Which is a [] enclosed expression list
//
bracketExpression

	returns [JFXExpression value] 	// Expression tree for stringExpressions

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> seqexp = new ListBuffer<JFXExpression>();
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Optional step expression
	//
	JFXExpression	stepEx = null;
	
	// Optional LT qualifier
	//
	boolean 	haveLT	= false;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: LBRACKET   
	
		( 	e1=expression
				{
					seqexp.append($e1.value);
					errNodes.append($e1.value);
				}
		     	(
		     			
	     				  (
	     				    
	     				    (
                                  COMMA
                                | {
                                        // Object literals need not be delimited, but everything
                                        // else must be. Object literals end in '}' of course
                                        //
                                        if (input.LA(-1) != RBRACE)
                                        {
                                            log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_MANDATORY_COMMA);
                                        }
                                  }
                            )
	     					e2=expression
	     						{
	     							seqexp.append($e2.value);
	     							errNodes.append($e2.value);
	     						}
	     				  )*
	     				  COMMA?

	                    
	                    {
	                    	// Explicit sequence detected
	                    	//
	                    	$value = F.at(rPos).ExplicitSequence(seqexp.toList());
	                    }
	                    
		     		| DOTDOT
		     			(LT { haveLT = true; })? 
		     			
		     			dd=expression	{ errNodes.append($dd.value); }
		     			
		     	    	( 
		     	    		STEP st=expression 
		     	    				{ 
		     	    					stepEx = $st.value; 
		     	    					errNodes.append($st.value); 
		     	    				} 
		     	    	)?
		     	    	
		     	    	{
		     	    		$value = F.at(rPos).RangeSequence($e1.value, $dd.value, stepEx, haveLT);
		     	    	}
		     	)
		     	
		     |  // Empty sequence 
		     	{
		     		 $value = F.at(rPos).EmptySequence();
		     	}
	    )
	  RBRACKET
	  {
	  	endPos($value);
	  }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList

	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: e1=expression
		
		{
			args.append		($e1.value);
			errNodes.append	($e1.value);
		}
		
		(
			(COMMA | { log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_MANDATORY_COMMA);} )	
			e2=expression
			
			{
				args.append		($e2.value);
				errNodes.append	($e2.value);
			}
		
		)*
		COMMA?
	|
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	JFXErroneous errNode = F.at(rPos).Erroneous(args.elems);
	endPos(errNode);
	args = new ListBuffer<JFXExpression>();
	args.append(errNode);
	
}

// ------------------------
// Optional expression list
// For the moment this is only used by New....
//
expressionListOpt
	
	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up

	: (LPAREN)=>LPAREN expressionList
		{
			$args = $expressionList.args;
		}
	   RPAREN

	|	// Was not present
	;

// -----
// Types
//
type

	returns [JFXType rtype]
	
@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: typeName 	{ errNodes.append($typeName.value); }
	
		cardinality
	
		{
		
			if	($typeName.value  instanceof JFXErroneous) {
			
				// The type did not parse correctly, so we create it as
				// an erroneous element
				//
				$rtype = F.at(rPos).ErroneousType(errNodes.elems);
				
			} else {
			
				$rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
			}
			endPos($rtype);
		}
		
	| typeFunction	{ $rtype = $typeFunction.rtype; }
	| typePrefixed	{ $rtype = $typePrefixed.rtype; }
	| typeStar		{ $rtype = $typeStar.rtype;		}
	;

// Catch an error when looking for a type. The only error we can
// have is that there was nothing that predict any of the alts, 
// so we create an error node for placing in the AST
//
catch [RecognitionException re] {
  
	// Now create an AST node that represents a missing type, The required entry
	// is of type Name so we use an identifier name that cannot exist in
	// JavaFX, so that IDEs can detect it.
	//
	// Note that if this was part of a type refernce: ':' tttt, then we want to
	// report the error with reference to the ':' as this is easier for the IDE
	// to handle.
	//	
	if	(input.LA(-1) == COLON) {
	
		rPos = pos(input.LT(-1));	// Get the start point of the previous token.
	}
	
	$rtype = F.at(rPos).ErroneousType(errNodes.elems);
	endPos($rtype);
	
   	// Now report the error as the user needs to know about it, but with 
   	// refernce to the error type
  	//
    reportError(re, $rtype);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
 }

typeFunction

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: FUNCTION 
 		LPAREN 
 			typeArgList 
 				{ 
 					for (JFXTree t : $typeArgList.ptypes) { 
 						errNodes.append(t); 
 					} 
 				}
		RPAREN 
		
			ret=typeReference 	{ errNodes.append($ret.rtype); }
			
          	cardinality	//TODO: this introduces an ambiguity: return cardinality vs type cardinality
          	
		{
			$rtype = F.at(rPos).TypeFunctional($typeArgList.ptypes.toList(), $ret.rtype, $cardinality.ary);
			endPos($rtype);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	$rtype = F.at(rPos).ErroneousType(errNodes.elems);
	endPos($rtype);
}

typePrefixed

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
 	: NATIVEARRAY IDENTIFIER { "of".equals($IDENTIFIER.text) }?=>type
 	
 		{
 			$rtype = F.at(rPos).TypeArray($type.rtype);
 			endPos($rtype);
 		}
 	;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

typeStar

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
 	: STAR cardinality
 	
 		{
 			$rtype = F.at(rPos).TypeAny($cardinality.ary);
 			endPos($rtype);
 		}
 	;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ----------------------------
// A list of types as arguments
//
typeArgList
 	
 returns [ListBuffer<JFXType> ptypes = ListBuffer.<JFXType>lb(); ]
 
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
 	: t1=typeArg
 	
 		{
 			ptypes.append($t1.rtype);
 		}
 		 
 		(
 			COMMA 	
			t2=typeArg
			
			{
				ptypes.append($t2.rtype);
			}
		
 		)*
 		COMMA?
 	|
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// -------------------------
// Individual typed argument
//
typeArg 

	returns [JFXType rtype]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
 	: (
 		(
 			name	// TODO: Check this, it is currently ignored for AST and does not
 					//       look quite right.
 		)? 
 			COLON
 	  )?
 	  
 	  type
 	
 		{
 			$rtype = $type.rtype;
 		}
 	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeReference

	returns	[JFXType rtype]
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
 	: COLON type
 			  
 		{
 			$rtype = $type.rtype;
 		}
 		
 	| // Untyped element, the AST needs to reflect that
 	
 		{ 
 			$rtype = F.at(rPos).TypeUnknown(); 
 			endPos($rtype);
 		}

 	;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
	// To avoid the complications of what to create class wise if
	// we get an error here, we create a dummy unknown type. Because
	// we log the error, we won't perform codegen, but the IDE will
	// have something to work with.
	//
	$rtype = F.at(rPos).TypeUnknown();
	endPos($rtype);
	
  	// Now, let's report the error as the user needs to know about it, but with
  	// reference to our new node.
  	//
    reportError(re, $rtype);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// -------------------------
// Array indicator for types
//
cardinality

	returns [TypeTree.Cardinality ary]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: (LBRACKET)=>LBRACKET RBRACKET
	
		{
			$ary = TypeTree.Cardinality.ANY;
		}
		
	|	{
			$ary = TypeTree.Cardinality.SINGLETON;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ----------
// Named type
// Possibly a generic
//
typeName

	returns [JFXExpression value]

@init
{
	// Accumulate any generic arguments
	//
	ListBuffer<JFXExpression> exprbuff = ListBuffer.<JFXExpression>lb();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
}

	: qualname 		{ errNodes.append($qualname.value); }
		(
			  (LT)=>LT ga1=genericArgument 	{ exprbuff.append($ga1.value); }
			  	
			  		(
			  			COMMA
	  					ga2=genericArgument
	  				
	  							{ exprbuff.append($ga2.value); }

			  		)* 
			  		COMMA?
			  GT
			  
			  {
			  	// AST for generic
			  	//
			  	JFXErroneous err = F.at(pos($LT)).Erroneous();
				endPos(err);
			  	log.error(err, MsgSym.MESSAGE_JAVAFX_GENERICS_UNSUPPORTED);
			  	
			  	// Ensure that the IDE plugin does not fall over
			  	//
			  	$value = $qualname.value;
			  }
			  
			|	// Non generic
				{
					
						$value = $qualname.value;
				}
		)
	| LPAREN typeparens RPAREN	// Allows cardinality coherence, using nested paren parsing trick
	
		{ $value = $typeparens.value; }
	;
	

	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
}

// When a programmer accidentally c=ecloses the type in two or more
// sets of prens, we do't want to change the type, but just treat extra
// parens as superfluous precedence, hence this rule.
//
typeparens

	returns [JFXExpression value]
	
	: (LPAREN)=>LPAREN t=typeparens RPAREN
	
		{ $value = $t.value; }
		
	| type
	
		{ $value = $type.rtype; }
	;

genericArgument

	returns [JFXExpression value]

@init 
{
	BoundKind 		bk 		= BoundKind.UNBOUND;
	JFXExpression 	texpr 	= null; 
}

	: typeName	{ $value = $typeName.value; }
	
	| QUES 
		(  
			( 
				  EXTENDS 		{ bk = BoundKind.EXTENDS; 	}
		  		| SUPER			{ bk = BoundKind.SUPER; 	}
		  	) 
		 	typeName			{ texpr = $typeName.value; }
		)?
		
		{
			// TODO: NYI - Remove or implement?
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal

	returns [JFXExpression value]
	
@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: 
		(
			 DECIMAL_LITERAL
			
				{
					$value = F.at(rPos).LiteralInteger($DECIMAL_LITERAL.text, 10);
				}
				
			| OCTAL_LITERAL
			
				{
					$value = F.at(rPos).LiteralInteger($OCTAL_LITERAL.text, 8);
				}
			
			| HEX_LITERAL
			
				{
					$value = F.at(rPos).LiteralInteger($HEX_LITERAL.text, 16);
				}
				
		    | timeValue
		    
		    	{
		    		$value = $timeValue.valNode;
		    	}
		    	
			| FLOATING_POINT_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.DOUBLE, Double.valueOf($FLOATING_POINT_LITERAL.text));
				}
				
			| TRUE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 1);
				}
				
			| FALSE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 0);
				}
				
			| NULL
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOT, null);
				}
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// -------------------------	
// Qualified (possibly) name
//
qualname

	returns [JFXExpression value, boolean inError]
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of this rule
	//
	int rPos = pos();
	
	// Indicates that despite parsing correctly, we discovered an error here
	// and so this shoudl be erroneous.
	//
	$inError = false;
	
	$value = null;
}
	: (
			n1=name
			{
				if	($n1.inError || $n1.value == null) {
				
					// The rule caused an identifier to be made up
					//
					$inError = true;
				}
				
				$value = F.at($n1.pos).Ident($n1.value);
				endPos($value);
			
				// Accumulate in case of error
				//
				errNodes.append($value);
			}
			(
				
				(DOT)=>DOT 

				(
						(nameAll)=>n2=nameAll
						{
							
							if	($n2.inError || $n2.value == null) {
				
								// The rule caused an identifier to be made up
								//
								//$inError = true;
							}
							
							$value = F.at(pos($DOT)).Select($value, $n2.value);
							endPos($value); 
							
							// Build up new node in case of error
							//
							JFXExpression part = F.at($n2.pos).Ident($n2.value);
							errNodes.append(part);
							endPos(part);
						}

					|	{
							$value = F.at(pos($DOT)).Select($value, Name.fromString(names, "<missing>"));
							endPos($value);
							log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
						}
				)
			)*  
		)
		
		// If the rule actually discovered some error, then we do
		// not return the $value as a good qualified name, but as an erroneous node
		//
		{
			if	($inError)	{
			
				// Create the error node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				endPos($value);
			}
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the error node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
	$inError = true;
	
}

// ----------
// Time value
// Invoked to pick up a specialized time token and create a special node
// that indicates it was missing, if the parser created it etc.
//
timeValue

	returns [JFXTimeLiteral valNode]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}

	: TIME_LITERAL
	
		{
			// Check to see if error recovery made up this value for us
			//
			if	($TIME_LITERAL instanceof MissingCommonToken) {
			
				$valNode = F.at(pos($TIME_LITERAL)).ErroneousTimeLiteral();
				
			} else {
			
				// Create a real node
				//
				$valNode = F.at(pos($TIME_LITERAL)).TimeLiteral($TIME_LITERAL.text);
			}
            endPos($valNode);
        }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {

  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the error node
	//
	$valNode = F.at(rPos).ErroneousTimeLiteral();
	endPos($valNode);
	
}
// -----------------------
// ID
// Basic identifier parse
//
identifier

	returns [JFXIdent value, boolean inError]

@init
{
	// Assume the input will be there
	//
	$inError = false;
		
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: IDENTIFIER
		{
			// The recovery mechanisms will auto generate the IDENTIFIER
			// token, in the case that it can predict that it was just a single
			// token that the programmer forgot to use. Hence we must
			// pick up on that and generate a different node for a Missing
			// identifier.
			//
			if ($IDENTIFIER instanceof MissingCommonToken) {
			
			    $value = F.at(rPos).ErroneousIdent();
			    endPos($value, pos());
			    $inError = true;
			    
			} else {
			
			    Name name = Name.fromString(names, $IDENTIFIER.text);
			    $value = F.at(rPos).Ident(name);
			    endPos($value, rPos + name.length());
			}
		}
	;

// -----------------------
// ID
// Basic identifier parse, but when Any keyword, including reserved
// words, is allowed.
//
identifierAll

	returns [JFXIdent value, boolean inError]

@init
{
	// Assume the input will be there
	//
	$inError = false;	

    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: IDENTIFIER
		{
			// The recovery mechanisms will auto generate the IDENTIFIER
			// token, in the case that it can predict that it was just a single
			// token that the programmer forgot to use. Hence we must
			// pick up on that and generate a different node for a Missing
			// identifier.
			//
			if ($IDENTIFIER instanceof MissingCommonToken) {
			
			    $value = F.at(rPos).ErroneousIdent();
			    endPos($value, pos());
			    $inError = true;
			    
			} else {
			
			    Name name = Name.fromString(names, $IDENTIFIER.text);
			    $value = F.at(rPos).Ident(name);
			    endPos($value, rPos + name.length());
			}
		}
		
	| aw=allWords
		{
			
			    Name name = Name.fromString(names, $aw.text);
			    $value = F.at(rPos).Ident(name);
			    endPos($value, rPos + name.length());
		}
	;
 
// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
name 

	returns [Name value, int pos, boolean inError]
@init
{
	// Assume the input will be there
	//
	$inError = false;	

    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = rPos; 
			
			if	($IDENTIFIER instanceof MissingCommonToken) {
			
				$inError = true;		// Recognizer manufactured this for us
			
			} else {
			
				$inError = false;		// It was genuinely there
			}
		}
	| aw=keyword
	    { 
			$value = Name.fromString(names, $aw.text); 
			$pos = rPos; 
	    }
	;
	
// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
nameAll 

	returns [Name value, int pos, boolean inError]
	
@init
{
	// Assume the input will be there
	//
	$inError = false;	

    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = rPos; 
			
			if	($IDENTIFIER instanceof MissingCommonToken) {
			
				$inError = true;		// Recognizer manufactured this for us
			
			} else {
			
				$inError = false;		// It was genuinely there
			}
		}
	| aw=allWords
	    { 
			$value = Name.fromString(names, $aw.text); 
			$pos = rPos; 
			$inError = false;
	    }
	;
	
// ----------
// All tokens
//
// The set of keywords, both reserved and non-reserved words, which
// can sometimes be used as Indentifiers, such as elements of
// import statements and second and subsequent elements of compound references
//
allWords
	: keyword
	| reservedWord
	;
	
// ---------------------
// Non-reserved keywords
//
// Some tokens are returned by the lexer as keywords for the grammar
// but are not reserved words in the language. These can be used as
// identifiers and are basically the set of keywords that cannot
// possibly start a statement/expression, such as 'to' but not those
// that are not sensible to allow as identifiers, such as 'true'.
//
keyword
    : FIRST     | IN    | INIT      | INTO
    | INVERSE   | LAST  | ON        | POSTINIT      
    | REPLACE   | STEP  | TRIGGER   | TWEEN
    | WHERE     | WITH  | INVALIDATE
    ;

// --------------
// Reserved words
//
// Tokens returned by the lexer that cannot be used as Identifiers
// but can be valid in some circumstances, such as components of
// an import statement, or as second and subsequent elements of
// compounds such as x.public.for.function()
//
reservedWord
	: ABSTRACT		| AFTER		| AND			| AS
	| ASSERT		| AT		| ATTRIBUTE		| BEFORE
	| BIND			| BOUND		| BREAK			| CATCH
	| CLASS			| CONTINUE	| DEF			| DELETE
	| ELSE			| EXCLUSIVE	| EXTENDS		| FALSE
	| FINALLY		| FOR		| FROM			| FUNCTION
	| IF			| IMPORT	| INDEXOF		| INSERT
	| INSTANCEOF	| LAZY		| MIXIN			| MOD
	| NATIVEARRAY	| NEW		| NOT			| NULL
	| OR			| OVERRIDE	| PACKAGE		| PRIVATE
	| PROTECTED		| PUBLIC	| PUBLIC_INIT	| PUBLIC_READ
	| RETURN		| REVERSE	| SIZEOF		| STATIC
	| SUPER			| THEN		| THIS			| THROW
	| TRUE			| TRY		| TYPEOF		| VAR
	| WHILE
	;


// -----------------------
// Process a SEMI colon that is always required, regardless of
// where the contruct is in the script. There are not too many
// of these.
//
requiredSemi 
	: { input.LA(1) != SEMI}?=>
	
	  // If there was no semi colon here, then we need to issue an error
	  // though we don't worry about it syntactically.
	  //
	  {
		  log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_SEMI_REQUIRED);
	  }
	
	| (SEMI)=>SEMI		// This is what we want	
	;

// -------------------------
// Decides whether a SEMI is required at this point in the parse (and issues
// an error if it is and is not present), or is optional (in which case it eats it) or
// we have just consumed one, which means we can not worry about it as the
// previous rule obviously decided that it wasn't optional and consumed it.
// This rule could result in doubly reporting the absent semi colon if there
// is a construct that consumes one, but does not find one, then a higher
// rule calls this rule, which also decideds one is necessary as it did not see one.
// However, the grammar is carefully soncstrcuted such that this does not happen
//
possiblyOptSemi
	: 	
			{
				// Call super class function to decide whether to look for
				// the SEMI or not and whether to log an error if one is 
				// missing.
				//
				checkForSemi();
			}
	;

