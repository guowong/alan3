#
# Copyright 1999-2009 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#

compiler.err.javafx.generalerror=\
    {0}.
compiler.err.javafx.lexer.literal.range=\
    {0} out of range: {1}.
compiler.err.javafx.range.start.int.or.number=\
    range start must be Integer or Number.
compiler.err.javafx.range.end.int.or.number=\
    range end must be Integer or Number.
compiler.err.javafx.range.step.int.or.number=\
    range step must be Integer or Number.
compiler.warn.javafx.range.literal.empty=\
    empty sequence range literal, probably not what you meant.
compiler.err.javafx.reserved.top.level.script.member=\
    reserved top-level script member {0}.
compiler.err.javafx.indexof.not.found=\
    cannot find \'for\' clause variable named {0}.
compiler.err.javafx.cannot.infer.return.type=\
    Non-final return requires explicit return type.
compiler.note.javafx.type.infer.cycle.fun.decl=\
    Need explicit type for {0} because of cycle in definition.
compiler.note.javafx.type.infer.cycle.var.decl=\
    Need explicit type for {0} because of cycle in initialization.
compiler.err.javafx.type.infer.cycle.var.ref=\
    This is the cyclic reference to {0} that prevents type inference.
compiler.err.javafx.function.type.infer.cycle=\
    Need explicit return type for {0} because it is recursive.
compiler.err.javafx.void.sequence.not.allowed=\
    Sequence of Void not allowed.
compiler.err.javafx.only.one.base.java.class.allowed=\
    More than one Java class extended. Extended class {0}.
compiler.err.javafx.only.mixins.and.interfaces=\
    Mixin classes may only extend interfaces and other mixins.
compiler.err.javafx.mixin.cant.be.instantiated=\
    {0} is a mixin; cannot be instantiated.
compiler.err.javafx.only.one.base.class.allowed=\
    Only one non-mixin based class allowed.
compiler.err.javafx.pure.mixin=\
    Mixins can not be abstract or interface.
compiler.err.javafx.repeated.mixin=\
    Repeated mixin.
compiler.err.javafx.duplicate.trigger.def=\
    Duplicate trigger definition.
compiler.err.javafx.duplicate.var.override=\
    Duplicate variable override: variable {0} already overriden in {1}
compiler.err.javafx.not.allowed.in.bind.context=\
    Not allowed in bind context {0}
compiler.misc.javafx.keyframe.literal=\
    keyframe literal
compiler.misc.javafx.self.ref=\
    self reference
compiler.misc.javafx.forward.ref=\
    forward reference
compiler.misc.javafx.try.catch=\
    try/catch block
compiler.err.javafx.expr.unsupported.for.bidi.bind=\
    Expression not supported for bind with inverse.
compiler.err.javafx.wrong.type.for.bidi.bind=\
    Type mismatch for bind with inverse\n\
    found: {0}\n\
    required: {1}
compiler.err.javafx.bound.var.in.bidi.bind=\
    Bound variables not supported for bind with inverse.
compiler.warn.javafx.select.target.not.reevaluated.for.bidi.bind=\
    In bind with inverse of {0}.{1}, {0} is not a constant, but will be treated as such. You may want to rewrite as:\n\
    \ \ def temp = {0};\n\
    \ \ var x = bind temp.{1} with inverse;\n\n
compiler.warn.javafx.select.target.not.reevaluated.for.anim=\
    In animation target {0}.{1}, {0} is not a constant, but will be treated as such. You may want to rewrite as:\n\
    \ \ def temp = {0}\n\
    \ \ temp.{1} => x\n\n
compiler.err.javafx.bound.override.meth=\
    Bound function cannot override non-bound function -- {0}
compiler.err.javafx.non.bound.override.meth=\
    Non-bound function cannot override bound function -- {0}
compiler.err.javafx.cant.override.var.from.func=\
    Cannot override variable {0} defined in {1} within a function definition.
compiler.err.plugin.cannot.find.plugin=\
    Cannot find platform plugin for specified platform: {0}
compiler.warn.plugin.cannot.load.plugin=\
    Cannot load platform plugin from file: {0}
compiler.err.javafx.base.java.class.non.papar.ctor=\
    Base Java class {0} does not have a default constructor.
compiler.err.javafx.must.be.an.attribute=\
    {0} must be an attribute.
compiler.err.javafx.bound.function.must.not.be.void=\
    Bound function must not be void.
compiler.err.neither.conditional.subtype=\
incompatible types for ''if'' - neither is a subtype of the other\n\
second operand: {0}\n\
third operand : {1}
compiler.err.javafx.invalid.assignment=\
    Invalid assignment
compiler.err.javafx.def.must.have.init=\
    The def {0} must have an initializing expression
compiler.err.javafx.cannot.assign.to.def=\
    You cannot change the value(s) of ''{0}'' because it was declared as a ''def'', perhaps it should be a ''var''?
compiler.err.javafx.cannot.assign.to.parameter=\
    You cannot change the value(s) of ''{0}'' because it is a parameter.
compiler.err.javafx.declared.overrride.does.not.override=\
    {0} {1} declared ''override'' but does not override another {0}.
compiler.err.javafx.var.not.supported.here=\
    ''{0}'' not currently supported in this location -- move {1} to the block level.
compiler.err.javafx.string.concatenation=\
+ cannot be applied to strings. Use a string expression "{0}"
compiler.err.javafx.loose.expressions=\
    {0}\n\
    Any expressions to be run on script invocation should be moved into run().
compiler.err.javafx.types.incompatible.vars=\
    types {0} and {1} are incompatible; both define {2}, but with unrelated types
compiler.misc.javafx.loose.expr.in.lib=\
    Loose expressions are not permitted in scripts with exported (''public'', etc) members.
compiler.misc.javafx.loose.expr.in.run=\
    Loose expression not permitted in scripts with a run() function.
compiler.err.javafx.run.function.single=\
    There must be no more than one ''run'' function.
compiler.err.javafx.run.function.param=\
    ''run'' function must either have no parameters or one parameter of type ''String[]''.\n\
    Use:     function run()    or\n\
    Or use:  function run(args : String[])
compiler.err.javafx.report.write.access=\
    {0} has {1} write access in {2}
compiler.err.javafx.report.var.query.access=\
    {0} has {1} access in {2}
compiler.err.javafx.report.bind.access=\
    {0} has {1} bind access in {2}
compiler.err.javafx.report.init.access=\
    {0} has {1} initialization access in {2}
compiler.err.javafx.not.supported.readable=\
    The ''readable'' keyword is no longer supported.  Please use ''public-readable'' to indicate that a variable can be read by the world.
compiler.err.javafx.not.supported.attribute=\
    The ''attribute'' keyword is no longer supported.  Please use ''def'' or ''var'' to declare class variables.
compiler.err.javafx.not.supported.private=\
    The ''private'' keyword is no longer supported.  The default access is script-private, so you can simply remove ''private''.
compiler.warn.javafx.generalwarning=\
    {0}.
compiler.warn.javafx.warn.on.use.package=[warnonuse] Package {0} has been used.
compiler.warn.javafx.function.overrides.another.should.be.declared.override=\
    Function {0} overrides another, it should be declared ''override''.
compiler.warn.javafx.static.deprecated=\
''static'' is no longer supported.  \
It will be removed from the language soon. \
Use script-level declarations for {0}.
compiler.warn.javafx.ambiguous.param.type.from.super=\
Ambiguous parameter type in potentially overridden methods.
compiler.warn.javafx.ambiguous.return.type.from.super=\
Ambiguous return type in potentially overridden methods.
compiler.warn.javafx.iterating.non.sequence=\
    iterating over a non-sequence
compiler.warn.javafx.explicit.thread=\
    explicit use of threads is not supported
compiler.warn.javafx.void.block.val.not.allowed=\
    void block value in non-void function
compiler.err.javafx.not.a.function=\
    The type {0} is not something that yields a callable function.\n\
    Perhaps you are accidentally trying to use it as a function because its definition does not end with a '';''.\n\
    Without the '';'' to separate a construct from a following parenthesized expression ''()'', the compiler will try to generate a function call.
compiler.err.javafx.cant.apply.function=\
  cannot apply a function which expects ({0}) to ({1})
compiler.err.javafx.applied.to.instance.var=\
The argument to the function {0} must be a reference to an instance ''var''.
compiler.err.javafx.mod.not.allowed.on.local=\
    modifiers (in this case {0}) not allowed on a local {1}
compiler.err.javafx.mod.not.allowed.on.script=\
    modifier {0} not allowed on a script level {1}
compiler.err.javafx.mod.not.allowed.on.instance=\
    modifier {0} not allowed on an instance {1}
compiler.err.javafx.mod.not.allowed.on=\
    modifier {0} not allowed on a {1}
compiler.err.javafx.already.defined.object.literal=\
    {0} is already defined in this object literal
compiler.err.javafx.cannot.init.static.object.literal=\
    script variable {0} cannot be initialized inside object literal expression
compiler.warn.javafx.redundant.access.modifiers=\
The access modifier {0} includes the access of {1}.
compiler.warn.maybe.forward.ref=\
Suspicious {0}: {1} {2} might not have been initialized.
compiler.warn.illegal.forward.ref=\
Illegal {0}: {1} {2} is not initialized.
compiler.err.illegal.forward.ref=\
Illegal {0}: {1} {2} is not initialized.
javafx.msg.bug=\
    An exception has occurred in the OpenJavafx compiler. \
    Please file a bug at the Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues) \
    after checking for duplicates. \
    Include the following diagnostic in your report and, if possible, the source code which triggered this problem.  Thank you.

compiler.note.javafx.internal.error=\
    An internal error has occurred in the OpenJFX compiler. Please file a bug at the\n\
    Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)\n\
    after checking for duplicates.  Include in your report:\n\
    - the following diagnostics\n\
    - file {0}\n\
    - and if possible, the source file which triggered this problem.\n\
    Thank you.

compiler.note.javafx.internal.error2=\
    An internal error has occurred in the OpenJFX compiler. Please file a bug at the\n\
    Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)\n\
    after checking for duplicates.  Include in your report:\n\
    - the following diagnostics\n\
    - and if possible, the source file which triggered this problem.\n\
    Thank you.

compiler.note.javafx.internal.error1=\
    OpenJavafx compiler version {0} \n\
    java.vm.version {1} \n\
    java.runtime.version {2} \n\
    os.name {3} \n\
    os.arch {4} \n\
    ---------- \n{5}\n----------
javafx.opt.arg.name=<platform>
javafx.opt.platform=Platform translator plug-in
javafx.opt.classpath=\
    Specify where to find user class files
opt.arg.path=\
    <path>
compiler.err.javafx.too.many.parameters=\
    sorry, not implemented: functions with more than 8 parameters
compiler.err.javafx.bind.too.complex=\
    sorry, not implemented: this bind is too complex.  Report this error and work-around by breaking down the bind.
compiler.err.javafx.bad.str.compound=\
    Compound strings may only contain literals strings for compile time evaluation, not expressions (such as say variables) that must be evaluated at run time.
compiler.err.javafx.cannot.modify.localvar=\
    Local variables cannot be declared with access modifiers such as 'publc', 'public-read' and so on.
compiler.err.javafx.bad.character=\
    Sorry, but the character ''{0}'' does not mean anything to me, at least on its own. Is this a Typo?
compiler.err.javafx.hex.malformed=\
    Hexadecimal literals can only contain characters '0' to '9' and 'a' to 'f' or 'A' to 'F'. Is this a typo?
compiler.err.javafx.hex.float=\
    Hexdecimal numbers cannot form floating point literals. Is this a typo?
compiler.err.javafx.hex.missing=\
    Hexadecimal numbers must have at least one hex character following the '0x'. Is this a typo?
compiler.err.javafx.octal.malformed=\
    Numbers starting with a leading '0' are assumed to be octal, but this one contains characters other than '0' to '7'.
compiler.err.javafx.octal.float=\
    Octal numbers (numbers with a leading '0') cannot be used to form floating point literals. Is this a typo?
compiler.err.javafx.exponent.malformed=\
    Numbers in scientific E notation must specify an exponent as 'E', optionally followed by '-' or '+', then a numeric exponent.
compiler.err.javafx.unterminated.string=\
    Unterminated string literal - missing '' or ".
compiler.err.javafx.unterminated.string.expression=\
    Unterminated embedded string expression - missing ''}''.
compiler.err.javafx.unescaped.rbrace=\
    The character ''\}'' should be escaped in a string literal to avoid confusion with embedded expressions such as "'{' variable '}'".
compiler.err.javafx.semi.required=\
    You have forgotten the '';'', which is needed to separate one expression from the next.
compiler.err.javafx.incomplete.qual=\
    You have missed out a part of the qualified name.
compiler.err.javafx.import.bad.name=\
    The ''.*'' part of an import can only be the last part of the sequence, as in aaa.bbbb.*
compiler.err.javafx.import.bad.star=\
    The ''.*'' part of an import can only be given once, and it must be the last part of the qualified name, as in aaa.bbb.*
compiler.err.javafx.func.unnamed=\
    A declared function must be given a function name.
compiler.misc.javafx.typed.override=\
    An override variable must have the same type as the overriden variable.
compiler.err.javafx.finally.toomany=\
    You have too many ''finally'' clauses for the associated ''try'' block; there can be only one.
compiler.err.javafx.finally.notlast=\
    You must declare a finally block as the last part of a ''try''...''catch''...''finally'' construct. This one comes before subseqeunt ''catch'' clauses.
compiler.err.javafx.bad.try=\
    A ''try''...''catch''...''finally'' construct must have at least one ''catch'' clause or a ''finally'' clause, or both. This one has neither.
compiler.err.javafx.orphaned.finally=\
    This ''finally'' block has been orphaned and has no ''try'' to which it belongs.
compiler.err.javafx.orphaned.catch=\
    This ''catch'' block has been orphaned and has no ''try'' to which it belongs.
compiler.err.javafx.garbled.expression=\
    There is a garbled expression starting here, I have tried to ignore it.
compiler.err.javafx.orphaned.else=\
    This ''else'' expression does not belong to any previous ''if'' expression.
compiler.err.javafx.garbled.declaration=\
    There is a garbled class member definition starting here, I have tried to ignore it. Class members can be ''var'', ''def'', ''function'', ''init'' or ''postinit'' only.
compiler.note.javafx.optimization.statistic=\
    Optimization statistic: {0}: {1}
compiler.err.javafx.bad.def=\
    The ''def'' of ''{0}'' must be intialized with a value here. Perhaps you meant to use ''var''?
compiler.err.javafx.bad.percent=\
    The operator ''%'' is not valid in JavaFX. If you need to calculate a modulo, use the ''mod'' binary operator instead. Note that there is no direct equivalent to '%='.
compiler.err.javafx.not.ne=\
    The operator ''<>'' is not valid in JavaFX. If you are trying to say ''not equal to'', use the operator ''!=''.
compiler.err.javafx.generics.unsupported=\
    Java style generics are not currently supported in JavaFX, so you cannot use them here.
compiler.err.javafx.bad.empty.sequence=\
    An empty sequence is not a valid expression for this operation, I am looking for an expression that yields ''{0}''
compiler.err.javafx.bad.sequence=\
    A sequence is not a valid expression for this operation, I am looking for an expression that yields ''{0}''
compiler.err.javafx.var.overrides.member=\
    ''var'' overrides member ''{0}'' in ''{1}''; use ''override''.
compiler.err.javafx.def.overrides.member=\
    ''def'' overrides member ''{0}'' in ''{1}''.
compiler.err.javafx.var.overrides.java.member=\
    ''var'' conflicts with Java member ''{0}'' in ''{1}''.
compiler.err.javafx.def.overrides.java.member=\
    ''def'' conflicts with Java member ''{0}'' in ''{1}''.
compiler.err.javafx.cannot.override=\
    Cannot override ''{0}'' -- this instance variable must be writeable.
compiler.err.javafx.cannot.override.own=\
    Cannot override ''{0}'' -- overridden variable must be from a supertype.
compiler.err.javafx.cannot.override.def=\
    Cannot override ''{0}'' -- ''{0}'' is a ''def''.
compiler.err.javafx.invalid.select.for.super=\
    The type-qualifier {0} cannot be used in this context; the qualifier must denote a direct superclass of {1}.
compiler.err.javafx.package.in.script.eval.mode=\
    Package declaration not allowed in script-evaluation mode.
compiler.misc.deprecated.interface.class=\
    Deprecated interface class file: {0}. Please recompile source file.
compiler.misc.javafx.seq.or.array=\
    Sequence (or nativearray)
compiler.misc.javafx.obj.or.seq=\
    Object or Sequence
compiler.err.javafx.for.over.iterable.disallowed.in.bind=\
    Within a bind, for-loops must not iterate over an Iterable.  Use sequences.
compiler.err.javafx.keyvalue.required=\
    KeyFrame literals must only contain KeyValue expressions within the braces, for example: SomeVariable => SomeValue
compiler.err.cant.inherit.from.script=\
    script class {0} cannot extend another class in the same script
compiler.err.trigger.in.bind.not.allowed=\
    {0} triggers are not allowed inside bind
compiler.err.var.in.bind.must.have.init=\
    Missing variable initializer for {0}\n\
    Variables defined in bind must be initialized explicitly.
compiler.err.on.invalidate.unbound.not.allowed=\
    on invalidate trigger cannot target unbound variable {0}
compiler.err.cant.invalidate.unbound.var=\
    cannot invalidate unbound variable {0}
compiler.err.cant.ref.invalidate.var=\
    Variable {0} is undefined inside on-invalidate trigger.
compiler.warn.javafx.unsupported.type.in.bind=\
    bind does not detect changes in nativearray value
compiler.warn.javafx.unsupported.type.in.trigger=\
    trigger does not detect changes in nativearray value
compiler.err.javafx.mandatory.comma=\
    It looks like you are missing a '','' delimiter or perhaps have a malformed expression here?
compiler.err.new.fxclass.no.args=\
    Attempting to create a JavaFX class using new with a non-empty parameter list. Use object literal instead.

# temporary messages to pass test
#
compiler.misc.version.resource.missing=\
    Resource bundle missing for version {0}.
compiler.misc.version.unknown=\
    Unknown version {0}.

compiler.misc.kindname.function=\
    function
